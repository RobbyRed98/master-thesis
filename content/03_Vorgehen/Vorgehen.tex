\chapter{Vorgehen}
\label{vorgehen}
Im Rahmen dieses Kapitels werden die Untersuchungs- und Analyse-Methoden erläutert, die für die Evaluation von Db2 Graph herangezogen wurden. 

\section{Performance-Analyse}
\label{vorgehen:performance-analyse}
Dieser Abschnitt beschreibt, welches Vorgehen für die Performance-Analyse von Db2 Graph gewählt wurde. Dabei gilt es zu erwähnen, dass sich das Vorgehen grob an den Messungen in \cite{sigmod_tian}. Darin wurden Db2 Graph und zwei weitere Graphdatenbanksysteme miteinander bezüglich der Linkbench-Performance verglichen \cite{sigmod_tian}. Allerdings muss darauf hingewiesen werden, dass die Messungen dieser Arbeit und in \cite{sigmod_tian} nicht vergleichbar sind. Weder die Db2 Graph Version(en), die Benchmark-Adapter und der für die Messungen eingesetzte Datensatz überschneiden sich. Der Benchmark Linkbench und die Metriken Latenz und Durchsatz wurden hingegen aus \cite{sigmod_tian} in diese Arbeit übernommen. 

\subsection{Benchmark}
Der Benchmark Linkbench wurde nicht ausschließlich als Mittel für die Performance-Analyse gewählt, weil dieser auch in \cite{sigmod_tian} eingesetzt wurde. 

Stattdessen wurde der Benchmark aus folgenden Gründen ausgesucht:
\begin{itemize}
    \item Es handelt sich bei Linkbench um einen Benchmark für Graph-Daten.
    \item Der Workload des Benchmarks ist einer realen Arbeitslast nachempfunden, auch wenn er sich hauptsächlich auf OLTP-Operationen beschränkt, siehe \autoref{linkbench:operationen}. 
    \item Auf der Basis der elementaren Graph-Operationen lässt sich bereits eine Einordnung der Performance von Db2 Graph oder Systemen vornehmen. 
    \item Linkbench ist flexibel konfigurier- und erweiterbar, siehe \autoref{linkbench}. 
    \item Der Aufwand für die Implementierung eines Adapters für Db2 Graph wurde als im Rahmen dieser Arbeit möglich eingeschätzt.
\end{itemize}
Bevor der Linkbench-Benchmark für die Performance-Analyse im Rahmen dieser Arbeit gewählt wurde, wurde auch der SNB-Benchmark als möglich Alternative gehandelt. Bei diesem  handelt es sich um einen deutlich neueren Benchmark für Graph-Daten als Linkbench \cite{snb_paper}. Dieser wurde vom LDBC-Projekt initiiert und entwickelt \cite{snb_paper}. Der Benchmark versucht dabei sowohl OLTP- als auch OLAP-Workloads abzubilden, anders als Linkbench der hauptsächlich OLTP-Operationen abdeckt \cite{snb_paper}. Die Wahl viel allerdings wie zuvor beschrieben auf Linkbench, da der Aufwand für die Anbindung von Db2 Graph an diesen Benchmark als geringer eingestuft wurde.  

\subsection{Vergleich}
Um die Linkbench-Ergebnisse von Db2 Graph später besser einordnen zu können, werden die Messergebnisse im Rahmen dieser Analyse mit denen des Datenbanksystems Neo4j verglichen. Dieses Vorgehen wurde hierbei gewählt, da es sich bei Neo4j um ein bekanntes, natives Graph-Datenbankmanagementsystem handelt. Dadurch stellt Neo4j einen aussagekräftige Referenz dar, an der Db2 Graph gemessen werden kann. 

\subsection{Implementierung}
Um Neo4j, Db2 Graph Beta 3 und Db2 Graph V11.5.6.0 an Linkbench anzubinden wurden im Rahmen dieser Arbeit vier verschiedenen Adapter implementiert. Zu diesen Adaptern gehören:
\begin{itemize}
    \item \texttt{Neo4j}-Adapter für Neo4j,
    \item \texttt{Db2GraphOld}-Adapter für Db2 Graph Beta 3, 
    \item \texttt{Db2Graph}-Adapter für Db2 Graph V11.5.6.0 und
    \item \texttt{Db2}-Adapter -- wird hauptsächlich von den Adaptern für Db2 Graph als Basis genutzt.
\end{itemize}
Weitere Details bezüglich der Implementierung werden in \todo{Referenz für Implementierungskapitel} erläutert.

\subsection{Operationen}
Für die Performance-Analyse der Datenbanksysteme werden im Rahmen dieser Arbeit die folgenden Operationen von Linkbench herangezogen:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink} und
    \item \texttt{getLinkList}.
\end{itemize}
Die Auswahl wurde getroffen, da Db2 Graph Beta 3 und v11.5.6.0 ausschließen lesende-Operationen unterstützen. Bei alle anderen Operationen die in \autoref{linkbench:operationen} aufgeführt werden handelt es sich jedoch um schreibende Operationen. Daher muss auf diese verzichtet werden. 

Im Zuge der Performance-Analyse der Datenbanksysteme werden allerdings bei Messungen mit real-verteilten Datensätzen vier verschiedene Varianten der \texttt{getLinkList}-Operation eingesetzt. Mehr dazu in \autoref{analyse:parameter}.

\subsection{Metriken}


\subsection{Parameter}
\label{analyse:parameter}
Die Messungen die im Rahmen dieser Arbeit durchgeführt werden, können anhand von zwei Hauptparametern unterschieden werden:
\begin{itemize}
    \item die Verteilung / Struktur der Datensätze und 
    \item die Größe der Datensätze. 
\end{itemize}
Diese beiden Messparameter spielen hierbei im Kontext aller Messungen eine wichtige Rolle. 

Darüber hinaus gibt es noch die zwei Nebenparameter:
\begin{itemize}
    \item Ergebnismenge und 
    \item Query-Stil. 
\end{itemize}
Diese spielen hierbei entweder bei Messungen mit real- oder mit konstant-verteilten Datensätzen eine Rolle.  

\subsubsection{Verteilung}
Bei der Struktur der Datensätze kann zwischen den beiden folgenden Verteilungen unterschieden werden: 

\begin{itemize}
    \item \textit{konstante Verteilung}\\
    Hierbei besitzt jeder Knoten im Datensatz exakt dieselbe Anzahl an Kanten (Links) wie jeder andere Knoten. Im Rahmen dieser Arbeit wurde bei allen Messungen immer eine konstante 10er-Verteilung gewählt. Dies bedeutet das jeder Knoten genau 10 Kanten aufweist.  
    \item \textit{reale Verteilung}\\
    Hierbei ist die Verteilung von Kanten (Links) auf Knoten einer realen Verteilung eines Social-Graphs nachempfunden. Die Anzahl der Kanten, über die ein Knoten verfügt, bewegt sich dabei bei allen Messungen die in dieser Arbeit durchgeführt werden zwischen 2 und ca. 5.000.000. Dabei gibt es sehr viele Knoten mit einer geringen Anzahl an Kanten wie zwei und einzelne Knoten die mehr als 1.000.000 Kanten aufweisen. 
\end{itemize}

Die real-Verteilung wurde hierbei für die Messungen gewählt, da sie eine realitätsnahe Zusammensetzung eines Social-Graphs aufweist. Die Messergebnisse lassen somit Schlüsse darauf zu, wie sich das System bei solchen Workloads in der Praxis verhalten würde.

Die konstante Verteilung wurde entgegen der real-Verteilung nicht aufgrund ihrer Praxis-nähe für die Messungen ausgewählt. Stattdessen wurde Sie für die Messungen herangezogen, da Db2 Graph Beta 3 bei ersten Versuchen Schwierigkeiten mit einer hohen Kantenzahl in real-Verteilten Datensätzen aufwies. Das Benchmarking der \texttt{getLinkList}-Operation verursachte hierbei früher oder später einen beinahe Stillstand des Benchmark-Durchlaufs. 

Dieses Verhalten kann hierbei damit begründet werden, dass sich Db2 Graph Beta 3 damit schwertut, mit großen Ergebnismengen von über 100.000 Kanten je Knoten zu arbeiten. Darüber hinaus kann dieses Problem von Db2 Graph Beta 3 mit real-verteilten Datensätzen auch nicht durch die Begrenzung der Ergebnismenge im Rahmen der Gremlin-Query gelöst werden. Schließlich beherrscht Db2 Graph Beta 3 die Optimierungstechnik \textit{Limit Pushdown} nicht, siehe \autoref{db2graph:optimierung}. 

Aufgrund dessen und da es nachvollziehbarer Weise nicht zielführend wäre, die maximale Kanten auf Knoten Verteilung eines real-verteilten Datensatzes zu verändern, wurde auch entschieden, konstant-verteilte Datensätze als Teil der Messungen mit aufzunehmen. Schließlich ergibt sich dadurch die Möglichkeit Messergebnisse für Db2 Graph Beta 3 zu erzielen und diese mit V11.5.6.0 und Neo4j zu vergleichen. Allerdings nur unter der Voraussetzung, dass eine kleine konstante Verteilung gewählt wird, wie die konstante 10er-Verteilung. 

Außerdem gilt es hierbei noch anzumerken, dass es keine Messungen von Db2 Graph Beta 3 und real-verteilten Datensätzen im Rahmen dieser Arbeit erfolgen. Da des zuvor angesprochenen Problems von Db2 Graph Beta 3 mit derart verteilten Datensätzen.

\subsubsection{Größe}
Dieser Hauptparameter wurde dabei für die Messungen gewählt, um herauszufinden, wie sich die Datenbanksysteme beim Umgang mit kleineren (Linkbench-10M) und größeren (Linkbench-100M) Datensätzen verhalten. 

Hierbei wird in dieser Arbeit zwischen Datensätzen mit der Knoten Anzahl 10 Millionen und 100 Millionen unterschieden. Angelehnt an \cite{sigmod_tian} werden die Messergebnisse für die verschiedenen Knotenzahlen hier auch als:
\begin{itemize}
    \item Linkbench-10M für 10 Millionen Knoten und 
    \item Linkbench-100M für 100 Millionen Knoten bezeichnet.
\end{itemize}
Dadurch fällt die Unterscheidung zwischen den beiden Größenordnungen leichter. 

Dabei muss allerdings im Auge behalten werden, dass sich die Größe der Datenmengen je nach Verteilung eines Datensatzes weiterhin unterscheiden kann. Schließlich verfügen die Datensätze bei gleicher Knoten Anzahl über unterschiedlich viele Kanten, siehe \autoref{tab:kanten_anzahl}. So weisen in \autoref{tab:kanten_anzahl} konstant verteilte Datensätze fast die doppelte Anzahl an Kanten auf, wie real-verteilte Datensätze, bei der identischen Konfiguration Größen-Parameters. 

\begin{table}[ht]
    \centering
    \begin{tabular}{l|r|r}
    \hline
    \rowcolor[HTML]{EFEFEF} 
    \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Verteilung}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-10M}} & \multicolumn{1}{c}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-100M}} \\ \hline
    real & ca. 53.000.000 Kanten & ca. 530.000.000 Kanten \\
    konstant & 100.000.000 Kanten & 1.000.000.000 Kanten \\ \hline
    \end{tabular}
    \caption{Übersicht Linkbench Kantenanzahl}
    \label{tab:kanten_anzahl}
    \vspace{1em}
    \textit{}
\end{table}

Aufgrund dessen sollte auch später vom Vergleich der Messergebnisse zwischen den unterschiedlich verteilten Datensätzen bei Linkbench-10M und Linkbench-100M abgesehen werden.

\subsubsection{Ergebnismenge}
Dieser Parameter regelt bei den Messungen mit real-verteilten Datensätzen, wie groß die Ergebnismenge bei der \texttt{getLinkList}-Operation maximal werden kann. Konkret legt der Parameter dabei fest, wie viele Kanten maximal Teil der Ergebnismenge einer \texttt{getLinkList}-Operation sein können.

Durch die Variation des Parameters kann hierbei ermittelt werden, wie sich die Größe der Ergebnismengen, auf die Performance der Datenbanksysteme auswirkt. 

Die Beschränkung der Ergebnismenge wird dabei in der Linkbench-Workload-Konfiguration vorgenommen. Für die Konfiguration muss dort der Wert für \texttt{range\_limit} angepasst werden. 

Dieser Parameter wird dabei als Bestandteil aller Messungen bei real-verteilten Datensätzen herangezogen. Schließlich sind bei diesen auch größere Ergebnismengen möglich. Das Limit der Ergebnismenge bei der \texttt{getLinkList}-Operation variiert bei diesen Messungen immer zwischen: 
\begin{itemize}
    \item 100,
    \item 1.000,
    \item 10.000 und
    \item 100.000.
\end{itemize}

So werden bei den Messungen mit Bezug zu real-verteilten Datensätzen statt der vier regulären, die folgenden sieben Operationen gebenchmarkt:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink},
    \item \texttt{getLinkList(100)},
    \item \texttt{getLinkList(1.000)},
    \item \texttt{getLinkList(10.000)} und
    \item \texttt{getLinkList(100.000)}.
\end{itemize}
Der Wert in der Klammer bei der \texttt{getLinkList}-Operation gibt dabei das Limit für die Ergebnismenge an. 

\subsubsection{Query-Stil}