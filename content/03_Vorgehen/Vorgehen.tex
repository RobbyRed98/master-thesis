\chapter{Vorgehen}
\label{vorgehen}
Dieses Kapitel befasst sich mit der Methode und dem Aufbau, der Performance-Analyse von Db2 Graph und Neo4j. Darüber hinaus wird auch darauf eingegangen welche Maßnahmen ergriffen wurden, um die von Db2 Graph erzeilte Performance einordnen zu können. 

\section{Reproduktion}
Wie in der \nameref{einleitung} beschrieben, war es das eigentliche Ziel dieser Arbeit, die in \cite{sigmod_tian} erzielten Werte für Db2 Graph zu reproduzieren und mit neuen Werten für Neo4j zu vergleichen. 

Allerdings stellte sich nach einigen Recherchen hierbei heraus, dass sich die Werte aus \cite{sigmod_tian} im Rahmen dieser Arbeit nicht reproduzieren lassen. 

Eine Reproduktion der Ergebnisse der Performance-Analyse aus \cite{sigmod_tian} setzt hierbei die folgenden sieben Punkte voraus:
\begin{itemize}
    \item dieselbe Version von Db2 Graph,
    \item dieselbe Db2- und Db2-Graph-Konfiguration,
    \item derselbe Benchmark,
    \item derselbe Db2-Graph-Benchmark-Adapter,
    \item dieselbe Benchmark-Konfiguration,
    \item derselbe Datensatz und 
    \item dieselbe Umgebung (OS, Ressourcen, etc.) wie in \cite{sigmod_tian}.
\end{itemize}
Von diesen sieben Voraussetzungen können im Rahmen der Arbeit jedoch lediglich zwei teilweise erfüllt werden. Bei diesen zwei Voraussetzungen, die sich teilweise erfüllen lassen, handelt es sich um den Benchmark und die Ressourcen. Die Ressourcen werden hierbei in \cite{sigmod_tian} recht genau beschrieben. Darüber hinaus wird in \cite{sigmod_tian} auch aufgeführt, dass Linkbench als Benchmark für die Messungen herangezogen wird. Allerdings wird keine Auskunft darüber gegeben, welche Version beziehungsweise Implementierung von Linkbench für die Messungen genutzt wird.

Bezüglich der anderen Punkte werden im Rahmen von \cite{sigmod_tian} keinerlei Informationen bereitgestellt. So ist beispielsweise nicht bekannt, mit welcher Version von Db2 Graph die Messungen durchgeführt wurden. Es ist allerdings wahrscheinlich, dass es sich weder um die Version Beta 3 noch V11.5.6.0 handelt, die über den Zeitraum der Arbeit verfügbar waren. Schließlich wurden beide Versionen mehrere Monate nach der Arbeit veröffentlicht. 

Über die Benchmark-Konfiguration und die Implementierung des für den Benchmark benötigten Db2-Graph-Benchmark-Adapter ist ebenfalls nichts bekannt. Genau so werden in \cite{sigmod_tian} keine Informationen bezüglich der  Konfiguration der Db2 Instanz und Db2 Graph angegeben, obwohl diese für die Reproduktion der Ergebnisse eine wichtige Rolle spielen. 

Bezüglich des Datensatzes werden hingegen ein paar Eigenschaften in \cite{sigmod_tian} aufgeführt. Wie und ob der dort verwendet Datensatz durch den Daten-Generator des Benchmarks erzeugt werden kann, ist jedoch weiterhin unklar.

\section{Neues Ziel}
Da die Reproduktion der Messungen aus \cite{sigmod_tian} nicht möglich ist, muss ein neues Ziel für den Rahmen dieser Arbeit definiert werden. 

So setzt sich die Arbeit nun zum Ziel, weiterhin eine Performance-Analyse für Db2 Graph durchzuführen und die dabei erzielten Ergebnisse mit denen von Neo4j zu vergleichen. So orientiert sich die Arbeit weiterhin, bei den folgenden Aspekten an \cite{sigmod_tian}:
\begin{itemize}
    \item Linkbench als Benchmark zur Messungen der Performance,
    \item Db2 Graph als gebenchmarktes Datenbanksystem,
    \item Arbeit mit den Datensatz Größen 10 Millionen und 100 Millionen Knoten (Linkbench-10 und Linkbench-100) und
    \item Arbeit mit den Metriken Latenz und Durchsatz.  
\end{itemize}
Allerdings beschreitet die Performance-Analyse dieser Arbeit nun neue Wege, da Sie ihren Schwerpunkt nun auf die Messung der Performance der Datenbanksysteme bei real- und konstant-verteilten Datensätzen legt. 

Eine weitere neue Aufgabe, die aufgrund des neuen Ziels Teil der Arbeit wird, stellt dabei die Suche nach bereits existierenden Linkbench-Adapter-Implementierungen für Db2 Graph und Neo4j dar. 

Sollten jedoch keine der für die Messungen benötigten Adapter-Implementierung verfügbar sein, müssen diese auch im Rahmen der Arbeit selbst implementiert werden. 

Abschließend gilt es darauf hinzuweisen, dass auch wenn beim neuen Ziel einige Elemente aus \cite{sigmod_tian} übernommen werden, die im Rahmen dieser Arbeit und die in \cite{sigmod_tian} erzielten Ergebnisse nicht vergleichbar sind.

\section{Operationen}
\label{analyse:operationen}
Für die Performance-Analyse der Datenbanksysteme werden im Rahmen dieser Arbeit die folgenden Operationen von Linkbench herangezogen:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink} und
    \item \texttt{getLinkList}.
\end{itemize}
Die Auswahl wurde getroffen, da Db2 Graph Beta 3 und V11.5.6.0 ausschließen lesende-Operationen unterstützen. Bei allen anderen Operationen die in \autoref{linkbench:operationen} aufgeführt werden handelt es sich jedoch um schreibende Operationen. Daher muss auf diese verzichtet werden. 

In \autoref{src:gremlin_queries} werden die Gremlin-Queries aufgeführt, die für das Benchmarking von Db2 Graph Beta 3 und Db2 Graph V11.5.6.0 eingesetzt wurden. 
\begin{lstlisting}[label=src:gremlin_queries,caption={ Gremlin Queries (regulär)},language=Java]
/* getNode */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID>);

/* getLink */
g.E()
 .hasLabel("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .has("ID1", <NODE_ID1>)
 .has("ID2", P.within(<NODE_ID2s>))

/* countLinks */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID>)
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .count()

/* getLinkList */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID1>)
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .limit(<LIMIT>);
\end{lstlisting}

Für das Benchmarking von Neo4j wurden hingegen die  Cypher-Queries in \autoref{src:cypher_queries}. Neo4j unterstützt zwar auch Gremlin als Abfragesprache \cite{gdbms}. Allerdings handelt es sich bei Cypher um die bevorzugte Abfragesprache zur Interaktion mit Neo4j \cite{gdbms}.

\begin{lstlisting}[label=src:cypher_queries,caption={Cypher Queries (regulär)},language=CQL]
/* getNode */
MATCH (n:node{id: $id}) 
RETURN n.id AS ID, n.type AS TYPE, 
    n.version AS VERSION, n.time AS TIME, 
    n.data AS DATA

/* getLink */
MATCH (n1:node{id: $id1})-[l:link{link_type: $link_type}]->(n2:node) 
WHERE n2.id IN $id2s 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION

/* countLinks */
MATCH (:node{id: $id1})-
    [l:link{link_type: $link_type}]->
    (:node) 
RETURN COUNT(l) AS COUNT

/* getLinkList */
MATCH (n1:node{id: $id1})-
    [l:link{link_type: $link_type}]->
    (n2:node) 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION 
LIMIT $limit
\end{lstlisting}

Im Zuge der Performance-Analyse der Datenbanksysteme werden allerdings bei Messungen mit real-verteilten Datensätzen vier verschiedene Varianten der \texttt{getLinkList}-Operation eingesetzt. Darauf wird in im Detail eingegangen \autoref{analyse:parameter}.

\section{Metriken}
\label{analyse:metriken}
Bei den Messungen im Rahmen der Arbeit werden die folgenden Metriken herangezogen: 

\begin{itemize}
    \item Latenz und 
    \item Durchsatz.
\end{itemize}

Der Begriff Latenz bezeichnet dabei den Zeitraum zwischen dem Abschicken einer Anfrage an ein Datenbanksystem und dem Eintreffen der Antwort auf die Anfrage. Alternative könnte die Latenz auch als Verarbeitungszeit betrachtet werden. 

Unter der Metrik Durchsatz wird dabei erfasst, wie viele Operationen pro Sekunde im Durchschnitt während einer Messung durchgeführt werden. 

Darüber hinaus werden während jeder Messungen die Betriebssystemstatistiken erfasst. NMON zeichnet dabei einmal pro Minute einen Datenpunkt auf. Diese Statistiken werden hierbei nicht als eine weitere Metrik betrachtet. Die registrierten Daten können allerdings bei der Auswertung der Ergebnisse ergänzend hinzugezogen werden.

\section{Parameter}
\label{analyse:parameter}
Im Rahmen dieses Abschnitts wird auf die Parameter eingegangen, die bei der Unterscheidung der im Rahmen der Arbeit durchgeführten Messreihen eine zentrale Rolle spielen. 
Dabei handelt es sich um die drei folgenden Hauptparameter:
\begin{itemize}
    \item Verteilung der Datensätze, 
    \item Größe der Datensätze und 
    \item Messumfang.
\end{itemize}
Diese drei Parameter werden als Hauptparameter bezeichnet, da sie bei allen Messungen eine Rolle spielen.

Neben diesen Hauptparametern existieren auch noch die folgenden zwei Nebenparameter:
\begin{itemize}
    \item Ergebnismenge und 
    \item Query-Stil. 
\end{itemize}
Sie werden so genannt, da eine Variation der beiden Messparameter ausschließlich zwischen im Kontext der Messreihen mit einer realer oder einer konstanten Verteilung stattfindet, nicht aber beiden. 

\subsection{Verteilung}
Bei der Verteilung der Datensätze kann als Parameter zwischen den beiden folgenden Verteilungen unterschieden werden: 
\begin{itemize}
    \item \textit{konstante Verteilung}\\
    Hierbei besitzt jeder Knoten im Datensatz exakt dieselbe Anzahl an Kanten (Links) wie jeder andere Knoten. Im Rahmen dieser Arbeit wurde bei allen Messungen immer eine konstante 10er-Verteilung gewählt. Dies bedeutet das jeder Knoten genau 10 Kanten aufweist.  
    \item \textit{reale Verteilung}\\
    Hierbei ist die Verteilung von Kanten (Links) auf Knoten einer realen Verteilung eines Social-Graphs nachempfunden. Die Anzahl der Kanten, über die ein Knoten verfügt, bewegt sich dabei bei allen Messungen die in dieser Arbeit durchgeführt werden zwischen 2 und ca. 5.000.000. Dabei gibt es sehr viele Knoten mit einer geringen Anzahl an Kanten wie zwei und einzelne Knoten die mehr als 1.000.000 Kanten aufweisen. 
\end{itemize}

Die real-Verteilung wurde hierbei für die Messungen gewählt, da sie eine realitätsnahe Zusammensetzung eines Social-Graphs aufweist. Die Messergebnisse lassen somit Schlüsse darauf zu, wie sich das System bei solchen Workloads in der Praxis verhalten würde.

Die konstante Verteilung wurde entgegen der real-Verteilung nicht aufgrund ihrer Praxis-nähe für die Messungen ausgewählt. Stattdessen wurde Sie für die Messungen herangezogen, da Db2 Graph Beta 3 bei ersten Versuchen Schwierigkeiten mit einer hohen Kantenzahl in real-Verteilten Datensätzen aufwies. Das Benchmarking der \texttt{getLinkList}-Operation verursachte hierbei früher oder später einen beinahe Stillstand des Benchmark-Durchlaufs. 

Dieses Verhalten kann hierbei damit begründet werden, dass sich Db2 Graph Beta 3 damit schwertut, mit großen Ergebnismengen von über 100.000 Kanten je Knoten zu arbeiten. Darüber hinaus kann dieses Problem von Db2 Graph Beta 3 mit real-verteilten Datensätzen auch nicht durch die Begrenzung der Ergebnismenge im Rahmen der Gremlin-Query gelöst werden. Schließlich beherrscht Db2 Graph Beta 3 die Optimierungstechnik \textit{Limit Pushdown} nicht, siehe \autoref{db2graph:optimierung}. 

Aufgrund dessen und da es nachvollziehbarer Weise nicht zielführend wäre, die maximale Kanten auf Knoten Verteilung eines real-verteilten Datensatzes zu verändern, wurde auch entschieden, konstant-verteilte Datensätze als Teil der Messungen mit aufzunehmen. Schließlich ergibt sich dadurch die Möglichkeit Messergebnisse für Db2 Graph Beta 3 zu erzielen und diese mit V11.5.6.0 und Neo4j zu vergleichen. Allerdings nur unter der Voraussetzung, dass eine kleine konstante Verteilung gewählt wird, wie die konstante 10er-Verteilung. 

Außerdem gilt es hierbei noch anzumerken, dass es keine Messungen von Db2 Graph Beta 3 und real-verteilten Datensätzen im Rahmen dieser Arbeit erfolgen. Da des zuvor angesprochenen Problems von Db2 Graph Beta 3 mit derart verteilten Datensätzen.

\subsection{Größe}
Dieser Hauptparameter wurde dabei für die Messungen gewählt, um herauszufinden, wie sich die Datenbanksysteme beim Umgang mit kleineren (Linkbench-10M) und größeren (Linkbench-100M) Datensätzen verhalten. 

Hierbei wird in dieser Arbeit zwischen Datensätzen mit der Knoten Anzahl 10 Millionen und 100 Millionen unterschieden. Angelehnt an \cite{sigmod_tian} werden die Messergebnisse für die verschiedenen Knotenzahlen hier auch als:
\begin{itemize}
    \item Linkbench-10M für 10 Millionen Knoten und 
    \item Linkbench-100M für 100 Millionen Knoten bezeichnet.
\end{itemize}
Dadurch fällt die Unterscheidung zwischen den beiden Größenordnungen leichter. 

Dabei muss allerdings im Auge behalten werden, dass sich die Größe der Datenmengen je nach Verteilung eines Datensatzes weiterhin unterscheiden kann. Schließlich verfügen die Datensätze bei gleicher Knoten Anzahl über unterschiedlich viele Kanten, siehe \autoref{tab:kanten_anzahl}. So weisen in \autoref{tab:kanten_anzahl} konstant verteilte Datensätze fast die doppelte Anzahl an Kanten auf, wie real-verteilte Datensätze, bei der identischen Konfiguration Größen-Parameters. 

\begin{table}[ht]
    \centering
    \begin{tabular}{l|r|r}
    \hline
    \rowcolor[HTML]{EFEFEF} 
    \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Verteilung}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-10M}} & \multicolumn{1}{c}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-100M}} \\ \hline
    real & ca. 53.000.000 Kanten & ca. 530.000.000 Kanten \\
    konstant & 100.000.000 Kanten & 1.000.000.000 Kanten \\ \hline
    \end{tabular}
    \caption{Übersicht Linkbench Kantenanzahl}
    \label{tab:kanten_anzahl}
\end{table}

Aufgrund dessen sollte auch später vom Vergleich der Messergebnisse zwischen den unterschiedlich verteilten Datensätzen bei Linkbench-10M und Linkbench-100M abgesehen werden.

\subsection{Messumfang}
Unter dem Begriff Messumfang, wird im Rahmen dieser Arbeit, die Anzahl an Graphoperationen, wie \texttt{getNode} oder \texttt{getLink} verstanden, die während eines Benchmarkdurchlaufs ausgeführt werden. Bei den in \autoref{analyse:messreihen} beschriebenen Messreihen nimmt der Parameter dabei entweder:
\begin{itemize}
    \item 2.500.000 oder
    \item 25.000.000 an. 
\end{itemize}
Das heißt, dass für das Benchmarking einer bestimmten Art an Graphoperationen (z.B. \texttt{countLinks}), diese Operation 2.500.000 oder 25.000.000 Mal ausgeführt wurde. 

Welchen der beiden Werte der Parameter dabei im Zuge einer Messreihe annimmt, hängt dabei davon ab, ob der Parameter  Ergebnismenge im Kontext dieser Messreihe eine Rolle spielt. Ist dies der Fall, wird der Wert 2.500.000 für den Messumfang herangezogen. Das ist dabei notwendig, da das Benchmarking der \texttt{getLinkList}-Operation mit großen Ergebnismengen, die Performance beeinträchtigt \todo{Referenziere Messergebnisse}. Durch einigen geringeren Messumfang kann somit sichergestellt werden, dass diese Messungen nicht den zeitlichen Rahmen eines Tages sprengen.

\subsection{Ergebnismenge}
\label{analyse:parameter:ergebnismenge}
Dieser Parameter regelt bei den Messungen mit real-verteilten Datensätzen, wie groß die Ergebnismenge bei der \texttt{getLinkList}-Operation maximal werden kann. Konkret legt der Parameter dabei fest, wie viele Kanten maximal Teil der Ergebnismenge einer \texttt{getLinkList}-Operation sein können.

Durch die Variation des Parameters kann hierbei ermittelt werden, wie sich die Größe der Ergebnismengen, auf die Performance der Datenbanksysteme auswirkt. 

Die Beschränkung der Ergebnismenge wird dabei in der Linkbench-Workload-Konfiguration vorgenommen. Für die Konfiguration muss dort der Wert für \texttt{range\_limit} angepasst werden. 

Dieser Parameter wird dabei als Bestandteil aller Messungen bei real-verteilten Datensätzen herangezogen. Schließlich sind bei diesen auch größere Ergebnismengen möglich. Das Limit der Ergebnismenge bei der \texttt{getLinkList}-Operation variiert bei diesen Messungen immer zwischen: 
\begin{itemize}
    \item 100,
    \item 1.000,
    \item 10.000 und
    \item 100.000.
\end{itemize}

So werden bei den Messungen mit Bezug zu real-verteilten Datensätzen statt der vier regulären, die folgenden sieben Operationen gebenchmarkt:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink},
    \item \texttt{getLinkList(100)},
    \item \texttt{getLinkList(1.000)},
    \item \texttt{getLinkList(10.000)} und
    \item \texttt{getLinkList(100.000)}.
\end{itemize}

Der Wert in der Klammer bei der \texttt{getLinkList}-Operation gibt dabei das Limit für die Ergebnismenge an. So nehmen die Platzhalter \texttt{<LIMIT>} und \texttt{\$limit}
in \autoref{src:gremlin_queries} und \autoref{src:cypher_queries} bei der \texttt{getLinkList}-Operation die zuvor aufgeführten Werte an, im Rahmen der Messungen.

\subsection{Query-Stil}
Der Query-Stil stellt einen weiteren Parameter Nebenparameter dar. Dabei wird zwischen sogenannten regulären Queries und ID-Queries unterschieden. 

Bei den regulären Queries handelt es sich um die Anfragen, die bereits in \autoref{src:gremlin_queries} und \autoref{src:cypher_queries} aufgeführt wurden. Die Queries werden als reguläre Queries bezeichnet, da sie nahezu Bestandteil aller Messreihen sind, auf diese wird in \autoref{analyse:messreihen} weiter eingegangen. 

Die sogenannten ID-Queries unterscheiden sich bezüglich der Logik der Abfrage nur geringfügig von sogenannten regulären Queries. Allerdings werden die Gremlin-Queries anders formuliert als bei den regulären Queries. So nutzen die Gremlin ID-Queries in \autoref{src:gremlin_id_queries} eine Gremlin-ID -- ähnlich der \texttt{vid} oder \texttt{eid} von Db2 Graph in \autoref{db2graph:funktionsweise} -- um einen bestimmten Knoten oder Kante direkt im ersten Schritt herauszufiltern. Dies ist in \autoref{src:gremlin_id_queries} daran erkennbar, dass dort parametrisierte Versionen der Steps \texttt{V()} und \texttt{E()} zum Einsatz kommen. Dabei wird zu Beginn auf die für die regulären Queries typischen \texttt{has}- und \texttt{hasLabel}-Steps verzichtet.

\begin{lstlisting}[label=src:gremlin_id_queries,caption={Gremlin ID-Queries},language=Java]
/* getNode */
g.V(["NODETABLE",<NODE_ID>]);

/* getLink */
g.E(["LINKTABLE", <NODE_ID1>, <NODE_ID2>, <LINK_TYPE>])

/* countLinks */
g.V(["NODETABLE",<NODE_ID1>])
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)

/* getLinkList */
g.V(["NODETABLE",<NODE_ID1>])
 .outE("LINKTABLE")
 .has("LINK_TYPE",  <LINK_TYPE>)
 .limit(<LIMIT>)
\end{lstlisting}

Die Logik zwischen den regulären und ID-Queries unterscheidet sich, wie zuvor erwähnt lediglich geringfügig. Dies beutet das alle Queries dieselben Informationen abfragen, außer bei der \texttt{getLink}-Operation. Während bei dieser Operationen bei den regulären Queries eine Menge an IDs (\texttt{<NODE\_ID2s>}) für den Endknoten genutzt werden, so wird bei den ID-Queries ausschließlich eine ID (<NODE\_ID2>) herangezogen. 

Aufgrund dessen und da der Hauptunterschied zwischen den Query-Stilen den Aufbau der Gremlin-Queries betrifft, muss bei den Cypher ID-Queries lediglich die \texttt{getLink}-Operation wie in \autoref{src:cypher_id_queries} dargestellt
angepasst werden. Dies ist notwendig, um sicherzustellen, dass die Gremlin und Cypher ID-Queries dieselbe Abfragelogik aufweisen und somit dieselben Informationen abfragen. 
\begin{lstlisting}[label=src:cypher_id_queries,caption={Cypher ID-Queries},language=CQL]
/* getLink */
MATCH (n1:node{id: $id1})-[l:link{link_type: $link_type}]->(n2:node{id: $id2}) 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION,
\end{lstlisting}

\section{Umgebung}
\label{analyse:umgebung}
Für alle Messungen, die Teil der Performance-Analyse sind, wird im Rahmen der Arbeit derselbe Server herangezogen. Bei diesem handelt es sich um einen Ubuntu-Server 20.04.2 LTS mit folgenden Charakteristika:
\begin{itemize}
    \item 32 CPUs (AMD EPYC 7502P), 
    \item 256 GB Arbeitsspeicher,
    \item 500 GB SSD-Hauptspeicher,
    \item \texttt{ext4} als Dateisystem und 
    \item dem Linux-Kernel \texttt{5.4.0-77-generic}.
\end{itemize}
Des Weiteren gilt es dabei herauszustellen, dass die folgenden Datenbanksysteme während Messungen alle als Docker-Container betrieben werden: 
\begin{itemize}
    \item Db2,
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}
Jedes dieser Systeme wird in einem eigenen Container betrieben. 

\section{Datenbanksysteme}
\label{analyse:datanbanksysteme}
Im Rahmen der Performance-Analyse werden Messungen mit den folgenden Datenbanksystemen durchgeführt: 
\begin{itemize}
    \item Db2 Graph Beta 3 (+ Db2),
    \item Db2 Graph V11.5.6.0 (+ Db2) und
    \item Neo4j.
\end{itemize}
In den folgenden Unterabschnitten werden dabei die wichtige Anwendungs- be\-zieh\-ungs\-wei\-se System-Konfigurationen beschrieben. 

\subsection{Db2}
Die beiden Db2 Graph Versionen verwenden im Rahmen der Performance-Analyse bei allen Messungen dieselbe Db2 Instanz. Dadurch wird gewährleistet, dass beide auf ein relationales Datenbankmanagementsystem zugreifen, das sich nicht in der Konfiguration zwischen den Db2 Graph Versionen unterscheidet. Außerdem können somit beide Db2 Graph Versionen auf Basis eines identischen Datensatzes operieren. Auf diese Weise kann eine Verzerrung der Messergebnisse vermieden werden und beide Versionen von Db2 Graph arbeiten während des Benchmarking unter denselben Voraussetzungen.

Bei der Db2 Instanz, die von beiden Db2 Graph Versionen genutzt wird, handelt es sich um die Db2 Advanced Edition in Version v11.5.5.1. Per Konfiguration wurden ihr 180 GB an Arbeitsspeicher zugewiesen. Darüber hinaus verfügt sie über die für Linkbench benötigte Datenbank \texttt{linkdb0}. Diese weist im Kontext aller Messungen das in \autoref{src:linkdb0_schema} beschrieben Datenbankschema auf:

\begin{lstlisting}[label=src:linkdb0_schema,caption={Db2 Instanz Datenbankschema für linkdb0},language=SQL]
CREATE TABLE linkdb0.nodetable
(
    id      bigint NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1),
    type    int       NOT NULL,
    version numeric   NOT NULL,
    time    int       NOT NULL,
    data    clob(48000)  NOT NULL,
    PRIMARY KEY (id)
) ORGANIZE BY ROW COMPRESS YES;

CREATE TABLE linkdb0.linktable
(
    id1        bigint  NOT NULL DEFAULT '0',
    id2        bigint  NOT NULL DEFAULT '0',
    link_type  bigint  NOT NULL DEFAULT '0',
    visibility smallint     NOT NULL DEFAULT '0',
    data       varchar(255) NOT NULL DEFAULT '',
    time       bigint  NOT NULL DEFAULT '0',
    version    bigint       NOT NULL DEFAULT '0',
    PRIMARY KEY (link_type, id1, id2)
) ORGANIZE BY ROW COMPRESS YES;

/* Exisitiert, wird aber nicht genutzt. */
CREATE TABLE linkdb0.counttable
(
    id        bigint NOT NULL DEFAULT '0',
    link_type bigint NOT NULL DEFAULT '0',
    count     int         NOT NULL DEFAULT '0',
    time      bigint NOT NULL DEFAULT '0',
    version   bigint NOT NULL DEFAULT '0',
    PRIMARY KEY (id, link_type)
) ORGANIZE BY ROW COMPRESS YES;
\end{lstlisting}

An dem in \autoref{src:linkdb0_schema} beschriebenen Schema kann dabei abgelesen werden, dass alle Tabellen adaptive Kompression nutzen. Darüber hinaus existiert in \autoref{src:linkdb0_schema} eine Count-Tabelle (\texttt{linkdb0.counttable}) die von den Linkbench-Adaptern für Db2 Graph Beta 3 und V11.5.6.0 nicht genutzt wird. Sie ist lediglich vorhanden, da Linkbench ihre Existenz voraussetzt. 

Neben dem Datenbankschema von \texttt{linkdb0} muss auch noch darauf hingewiesen werden, dass die Datenbank einen Bufferpool (\texttt{IBMDEFAULTBP}) der Größe 163,920 GB nutzt. Der Bufferpool besteht dabei aus exakt 40.000.000 Seiten, mit einer Seitengröße (\texttt{PAGESIZE}) von 4096 Byte.

\subsection{Db2 Graph}
Die Version Beta 3 und V11.5.6.0 von Db2 Graph verfügen im Rahmen der Performance-Analyse eine vergleichbare Konfiguration. Lediglich die in V11.5.6.0 neu eingeführte \texttt{db2graph-server.yaml} und \texttt{db2graph-internal.yaml} sorgen dafür, dass es Konfigurationsunterschiede zwischen beiden Versionen gibt. Auf diese beiden Konfigurationen wird allerdings nicht näher eingegangen. Schließlich wurden die beiden Konfigurationen nicht für die Messungen angepasst. Somit wird im Rahmen der Performance-Analyse die mit Db2 Graph V11.5.6.0 ausgelieferte Standard-Konfiguration von \texttt{db2graph-server.yaml} und \texttt{db2graph-internal.yaml} her\-angezogen.

Die \texttt{gremlin-server.yaml} Konfiguration sowie die Ressourcen-Parameter des Gremlin-Servers von Db2 Graph Beta 3 und V11.5.6.0 wurde beide allerdings gleichermaßen für die Messungen angepasst. Unter diese Anpassungen fallen:
\begin{itemize}
    \item \textit{Gremlin-Memory}\\
    Dieser Ressourcen-Parameter legt fest wie viel Memory der Gremlin-Server des TinkerPop-Stacks im maximal Fall nutzen kann. Der Standard-Wert beträgt hier bei beiden Db2 Graph Versionen normalerweise 4 GB. Um eine möglichst hohe Performance mit beiden Db2 Graph Versionen zu erzielen wurde das Memory-Limit für den Gremlin-Server im Rahmen der Messungen allerdings auf 64 GB angehoben. 
    \item \textit{Thread-Pool-Worker}\\
    Der Wert für Thread-Pool-Worker regelt, wie viele Threads für die Verarbeitung von nicht-blockenden Operationen im Gremlin-Server bereitstehen \cite{tinkerpop_2020}. Der Wert ist dabei normalerweise auf 0 gesetzt, was zur Folge hat, das die Anzahl von verfügbaren Prozessoren herangezogen wird \cite{tinkerpop_2020}. Dies hätte im Rahmen der Messumgebung zur Folge, dass die Thread-Pool-Worker standardmäßig auf 32 gesetzt werden würden. 
    
    Um eine möglichst hohe Performance für die Db2 Graph Versionen bei den Messungen zu gewährleisten, wurde der Wert allerdings auf 128 erhöht. Da es dadurch den Gremlin-Server dahingehen unterstützt, große Lasten besser zu verarbeiten. So ist es dem Gremlin-Server dadurch möglich 50 oder 100 Anfragen, die von den entsprechenden Linkbench-Threads während des Benchmarking gesendet werden, auf einmal zu bearbeiten. 
    \item \textit{Gremlin-Pool}\\
    Der Wert für den Gremlin-Pool spezifiziert, wie viele Threads dem Gremlin-Server für die Verarbeitung von blockenden Operationen zur Verfügung stehen \cite{tinkerpop_2020}. Ähnlich wie Thread-Pool-Worker zieht er in der Standard-Konfiguration die verfügbare Prozessoranzahl (32) heran \cite{tinkerpop_2020}. Um eine höhere Performance zu erreichen, wurde er allerdings ebenfalls auf 128 erhöht. 
    
    Die Erhöhung wurde hierbei allerdings lediglich als eine Art Vorsichtsmaßnahme durchgeführt. Schließlich unterstützt Db2 Graph lediglich lesende Queries. Dies hat zur Folge, dass der Gremlin-Server eigentlich nicht auf blockende Operationen zurückgreifen sollte. Allerdings ist nicht bekannt, ob Db2 Graph in der Praxis wirklich nur auf nicht-blockende Operationen zurückgreift. Daher wurde der Wert des Gremlin-Pools analog zu Thread-Pool-Worker angehoben. 
\end{itemize}

Beide Versionen von Db2 Graph nutzen darüber hinaus die in \autoref{src:db2graph_mapping} dargestellte Graph-Overlay-Konfiguration, zum Mapping der in \autoref{src:linkdb0_schema} beschrieben Tabellen auf eine Graphstruktur. Hierbei wird die \texttt{linkdb0.nodetable} aus \autoref{src:linkdb0_schema} als Vertex-Tabelle in \autoref{src:db2graph_mapping} herangezogen, während die \texttt{linkdb0.linktable} die Rolle einer Edge-Tabelle übernimmt. 
\begin{lstlisting}[label=src:db2graph_mapping,caption={Graph-Overlay-Konfiguration Db2 Graph},language=json]
...
"jdbc_num_conn": 100,
"v_tables": [
    {
        "vid": {
            "prefix": "LINKDB0.NODETABLE",
            "id_cols": [
                "ID"
            ]
        },
        "table_id": "LINKDB0.NODETABLE",
        "table": {
            "schema_name": "LINKDB0",
            "table_name": "NODETABLE"
        },
        "label": {
            "fixed_label": true,
            "label": "NODETABLE"
        }
    }
],
"e_tables": [
    {
        "src_v_cols": [
            "ID1"
        ],
        "dst_v_cols": [
            "ID2"
        ],
        "src_v_tables": [
            "LINKDB0.NODETABLE"
        ],
        "dst_v_tables": [
            "LINKDB0.NODETABLE"
        ],
        "eid": {
            "implicit_id": false,
            "id": {
                "prefix": "LINKDB0.LINKTABLE",
                "id_cols": [
                    "LINK_TYPE",
                    "ID1",
                    "ID2"
                ]
            }
        },
        "table_id": "LINKDB0.LINKTABLE",
        "table": {
            "schema_name": "LINKDB0",
            "table_name": "LINKTABLE"
        },
        "label": {
            "fixed_label": true,
            "label": "LINKTABLE"
        }
    }
]
\end{lstlisting}

\subsection{Neo4j}
Alle Messungen die im Rahmen der Performance-Analyse durchgeführt werden, nutzen dieselbe Neo4j-Instanz. Bei dieser Instanz handelt es sich um die Community-Edition von Neo4j in Version 4.3. An der Konfiguration von Neo4j ändert sich zwischen den verschiedenen Messreihen nichts. Sie weist somit immer dieselbe Konfiguration auf. Bei dieser Konfiguration gilt es die folgenden Parameter hervorzuheben: 
\begin{itemize}
    \item 160 GB Page Cache und
    \item maximaler JVM Heap 64 GB.
\end{itemize}
Der Page Cache kann hierbei als das Neo4j-Pendant zum Bufferpool von Db2 betrachtet werden. Daher wurde mit ca. 164 GB und 160 GB auch eine vergleichbare Konfiguration für beide gewählt. Der JVM Heap in Neo4j und der Gremlin-Memory von Db2 Graph wurden hierbei aufgrund ihrer ähnlichen Funktion ebenfalls als vergleichbar angesehen, weshalb beide auf 64 GB gesetzt wurden.

Bei Neo4j handelt es sich um eine native Graphdatenbank, die auf dem in \autoref{datenmodelle} beschrieben Graphmodell basiert. Dadurch unterstützt Neo4j ein flexibles Datenbankschema, wie in \autoref{datenmodelle:structure}bereits beschrieben. Neo4j unterstützt allerdings trotz des flexiblen Schemas die Definition von Constraints. Ein solcher Constraint und ein Index werden hierbei in den Graphdatenbank eingerichtet, um einen fairen Vergleich von zwischen den Db2graph Versionen (+ Db2) und Neo4j zu ermöglichen. Der in \autoref{src:neo4j_schema} beschriebene Constraint und Index werden hierbei eingeführt, um dafür zu sorgen, dass ähnliche Indexe wie in Db2 auch in Neo4j existieren. Schließlich werden in Db2 beim Anlegen eines Primärschlüssels automatisch Indexe für dessen Bestandteile erzeugt. Zum Ausgleich werden daher die \autoref{src:neo4j_schema} spezifizierten Konstrukte angelegt. Der Constraint in \autoref{src:neo4j_schema} sorgt dabei dafür, dass keine Knoten mit dem Label \texttt{node}, dieselbe ID aufweisen können. Zugleich wird im Zuge dessen auch ein Index auf die ID von \texttt{node}-gelabelten Knoten erstellt.

\begin{lstlisting}[label=src:neo4j_schema,caption={Neo4j Instanz Datenbankschema},language=CQL]
// Constraint aehnlich einem Primaerschluessel fuer Knoten
CREATE CONSTRAINT unique_node_id 
ON (n:node) ASSERT n.id IS UNIQUE;

// Index fuer die Kanten-Property link_type
CREATE INDEX link_type_index 
FOR ()-[l:link]-() 
ON (l.link_type);
\end{lstlisting}

\section{Messreihen}
\label{analyse:messreihen}
Die im Rahmen dieser Arbeit durchgeführten Messungen werden auf Basis einer bestimmten Konfiguration der Parameter aus \autoref{analyse:parameter} in Messreihen eingeteilt. Die Zusammensetzung dieser Messreihen werden dabei im Rahmen dieses Abschnitts beschrieben. 

Bevor damit allerdings begonnen werden kann, werden hier nochmals kurz die Parameter und Konfigurationen zusammengefasst, die über alle Messreihen hinweg konstant bleiben:
\begin{itemize}
    \item \textit{Umgebung}\\
    In der in \autoref{analyse:umgebung} beschrieben Umgebung, werden alle Messreihen durchgeführt. 
    \item \textit{Linkbench-Threads}\\
    Linkbench arbeitet in der Request-Phase immer mit 50 Threads die gleichzeitig Anfragen an ein Datenbanksystem schicken.
    \item \textit{Db2 Datenbankschema}\\
    Das Db2-Datenbankschema von \texttt{linkdb0} aus \autoref{src:linkdb0_schema} wird zwischen den Messreihen nicht verändert oder angepasst. 
    \item \textit{Konfiguration Db2 Graph Beta 3 \& V11.5.6.0}\\
    Die Graph-Overlay-Konfiguration in \autoref{src:db2graph_mapping} und die Gremlin-Server-Konfiguration der Db2 Graph Versionen bleiben über alle Messungen hinweg unverändert.
    \item \textit{Konfiguration \& Datenbankschema Neo4j}\\
    Die in Konfiguration von Neo4j und das bei den Messungen eingesetzte Datenbankschema \autoref{src:neo4j_schema} bleiben über die Messreihen hinweg unverändert. 
\end{itemize}

In den folgenden Unterabschnitten werden nun die verschiedenen Messreihen genauer erläutert. Der Name einer Reihe setzt sich dabei aus dem Namen des Benchmarks (Linkbench), der Abkürzung für die gewählte Verteilung (Const oder Real) des Datensatzes und der Größe des Datensatzes (10M oder 100M) zusammen. Falls bei einer Messreihe ID-Queries statt den regulären Queries zum Einsatz kommen, wird abschließend noch ID angehängt.

\subsection{Linkbench-Const-10M}
Im Rahmen dieser Messreihe werden Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j durchgeführt. 
\end{itemize}
Die Messungen werden dabei auf Basis der folgenden Eigenschaften beziehungsweise Parameter durchgeführt:
\begin{itemize}
    \item reguläre Queries,
    \item Messumfang von 25.000.000,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Wie bei den Parametern beschrieben werden im Rahmen dieser Messreihe die regulären Queries herangezogen. Der für die Messungen erzeugte Datensatz besteht hingegen aus 10 Millionen Knoten und 100 Millionen Kanten. Darüber hinaus weist er eine konstante 10er-Verteilung auf. Das bedeutet jeder Knoten verfügt über exakt 10 ausgehende Kanten. 

Der Parameter Ergebnismenge beziehungsweise, dessen Variation, spielt im Kontext der Messreihe keine Rolle. So wird der Parameter bei allen Messungen der \texttt{getLinkList}-Operation auf 10.000 beschränkt. In der Praxis sollte diese Beschränk\-ung jedoch nie zum Einsatz kommen. Denn aufgrund der konstanten 10er-Verteilung des Datensatzes, weist jeder Knoten immer exakt 10 Kanten auf. Dies hat zur Folge, dass die Ergebnismenge im Maximalfall aus diesen 10 Kanten bestehen kann. 

Da das Benchmarking einer Operationsart aufgrund der konstant kleinen Ergebnismenge voraussichtlich den Zeitraum eines Tages einhalten kann, wird hier ein Messumfang von 25.000.000 gewählz.

\subsection{Linkbench-Const-10M-ID}
Teil dieser Messreihe sind Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Zugleich finden allen Messungen im Rahmen der Messreihe auf der Basis der folgenden Haupt- und Nebenparameter statt:
\begin{itemize}
    \item Queries-ID,
    \item Messumfang von 25.000.000,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Die Messreihe ähnelt in ihrer Beschaffenheit der Messreihe Linkbench-Const-10M. Der Datensatz bei den Messungen weist eine konstante 10er-Verteilung auf und setzt sich aus 10 Millionen Knoten und 100 Millionen Kanten zusammen. Die Beschränkung der Ergebnismenge spielt ebenfalls keine Rolle, weshalb auch ein Messumfang von 25.000.000 herangezogen werden kann. 

Lediglich der Query-Stil unterscheidet sich von dem von  Linkbench-Const-10M. So werden bei den Messungen im Rahmen dieser Reihe, die ID-Queries statt der regulären Queries herangezogen. Es handelt sich hierbei um die einzige Messreihe im Rahmen der Arbeit, bei der dies der Fall ist.

\subsection{Linkbench-Const-100M}
Im Kontext dieser Reihe erfolgen Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Hierbei werden folgende Parameter bei allen Messungen herangezogen:
\begin{itemize}
    \item reguläre Queries,
    \item Messumfang von 25.000.000,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-100M (Datensatzgröße).
\end{itemize}
Bei allen Messungen, die Teil dieser Messreihe sind, wird ein konstant (10) verteilter Datensatz eingesetzt, welcher 100 Millionen Knoten und 1 Milliarde Kanten umfasst. Des Weiteren kommen bei diesen Messungen die regulären Queries zum Einsatz. 

Die Ergebnismenge als Parameter spielt im Rahmen dieser Reihe aus denselben Gründen wie bei Linkbench-Const-10M und Linkbench-Const-10M-ID keine Rolle. Dementsprechend nimmt der Messumfang auch hier 25.000.000 an.

\subsection{Linkbench-Real-10M}
Bei dieser Messreihe werden Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j durchgeführt. 
\end{itemize}

Die Messungen im Rahmen dieser Messreihe werden dabei mit folgenden Parametern durchgeführt:
\begin{itemize}
    \item reguläre Queries,
    \item Messumfang von 2.500.000,
    \item variierende Beschränkung der Ergebnismenge,
    \item reale Verteilung (Datensatz) und 
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Bei den im Kontext der Reihe durchgeführten Messungen werden demnach die regulären Queries eingesetzt. Außerdem wird bevor die Messungen vorgenommen werden können, ein Datensatz mit einer realen Verteilung erzeugt. Dieser erzeugte Datensatz, welcher für das Benchmarking der Datenbanksysteme herangezogen wird, setzt sich dabei aus 10 Millionen Knoten und ca. 53 Millionen Kanten zusammen. Darüber hinaus werden im Rahmen der Messreihe, die Beschränkung der Ergebnismenge, das auch als Range-Limit bezeichnet wird, variiert. So gibt es Messungen mit dem regulären Range-Limit von 100 und 1.000, 10.000 sowie 100.000. Um das Benchmarking einer Operationsart hier im zeitlichen Rahmen eines Tages durchführen zu können, wird bei dieser Messreihe ein Messumfang von 2.500.000 gewählt. 

\subsection{Linkbench-Real-100M}
Teil dieser Reihe sind Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Außerdem finden allen Messungen im Kontext der Messreihe auf der Basis der folgenden Haupt- und Nebenparameter statt:
\begin{itemize}
    \item reguläre Queries,
    \item Messumfang von 2.500.000,
    \item variierende Beschränkung der Ergebnismenge,
    \item reale Verteilung (Datensatz) und
    \item Linkbench-100M (Datensatzgröße).
\end{itemize}
Die Messreihe ähnelt hier im Aufbau der Linkbench-Real-10M Reihe stark. So werden bei dieser ebenfalls reguläre Queries eingesetzt, der Messumfang beträgt 2.500.000, es werden mehrere Messungen für die \texttt{getLinkList}-Operation durchgeführt, mit variierendem Range-Limit und der Datensatz auf dem die Messungen basieren ist auch real verteilt. Allerdings umfasst der hierbei verwendete Datensatz 100 Millionen Knoten und ca. 530 Millionen Kanten, statt den 10 Millionen Knoten und ca. 53 Millionen Kanten bei der Messreihe Linkbench-Real-10M.

\subsection{Übersicht}
In diesen Abschnitt werden alle Messreihen und ihre Parameter nochmals übersichtlich in den beiden Tabellen \autoref{tab:uebersicht_messreihen_datensatz} und \autoref{tab:uebersicht_messreihen_parameter} zusammengefasst. In \autoref{tab:uebersicht_messreihen_datensatz} werden dabei die Datensatz-spezifischen Parameter der Messreihen aufgeführt. Die Parameter Messumfang, Ergebnismenge und der Query-Stil werden hingegen in \autoref{tab:uebersicht_messreihen_parameter} aufgelistet.

\begin{table}[h]
    \centering
    \begin{tabular}{l|r|r|c}
    \hline
    \rowcolor[HTML]{EFEFEF} 
    \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}{\color[HTML]{333333} }} & \multicolumn{3}{c}{\cellcolor[HTML]{EFEFEF}\textbf{Datensatz}} \\ \cline{2-4} 
    \rowcolor[HTML]{EFEFEF} 
    \multicolumn{1}{c|}{\multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}{\color[HTML]{333333} \textbf{Messreihe}}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Knoten}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Kanten}} & \multicolumn{1}{l}{\cellcolor[HTML]{EFEFEF}\textbf{Verteilung}} \\ \hline
    Linkbench-Const-10M & 10.000.000 & 100.000.000 & konstant \\
    Linkbench-Const-10M-ID & 10.000.000 & 100.000.000 & konstant \\
    Linkbench-Const-100M & 100.000.000 & 1.000.000.000 & konstant \\
    Linkbench-Real-10M & 10.000.000 & 100.000.000 & real \\
    Linkbench-Real-100M & 100.000.000 & 1.000.000.000 & real \\ \hline
    \end{tabular}
    \caption{Übersicht Datensatzparameter der Messreihen}
    \label{tab:uebersicht_messreihen_datensatz}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{l|r|c|l}
    \hline
    \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}{\color[HTML]{333333} }} & \multicolumn{1}{l|}{\cellcolor[HTML]{EFEFEF}} & \cellcolor[HTML]{EFEFEF} & \multicolumn{1}{c}{\cellcolor[HTML]{EFEFEF}} \\
    \multicolumn{1}{c|}{\multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}{\color[HTML]{333333} \textbf{Messreihe}}}} & \multicolumn{1}{l|}{\multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}\textbf{Messumfang}}} & \multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}\textbf{\begin{tabular}[c]{@{}c@{}}Variation der \\ Ergebnismenge\end{tabular}}} & \multicolumn{1}{c}{\multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}\textbf{Queries}}} \\ \hline
    Linkbench-Const-10M & 25.000.000 & - & regulär \\
    Linkbench-Const-10M-ID & 25.000.000 & - & ID \\
    Linkbench-Const-100M & 25.000.000 & - & regulär \\
    Linkbench-Real-10M & 2.500.000 & x & regulär \\
    Linkbench-Real-100M & 2.500.000 & x & regulär \\ \hline
    \end{tabular}
    \caption{Übersicht Parameter der Messreihen}
    \label{tab:uebersicht_messreihen_parameter}
\end{table}

\section{Ablauf der Messungen}
Im Rahmen dieses Abschnitts wird darauf eingegangen, wie die Messungen der Datenbanksysteme als Teil der in \autoref{analyse:messreihen} beschriebenen Messreihen durchgeführt werden. 

Um die Performance eines Datenbanksystems zu messen, werden mehrere Benchmark-Durchläufe durchgeführt. Dabei wird für jede gebenchmarkte Operation ein eigener Benchmark-Durchlauf ausgeführt. So macht eine Operation immer 100 \% des Operationsmix während eines Durchlaufs aus. 

Je nachdem als Teil welcher Messreihe die Performance eines Datenbanksystems gemessen wird, werden dabei die vier in \autoref{analyse:operationen} aufgeführten oder die sieben in \autoref{analyse:parameter:ergebnismenge} dargestellten Operationen gebenchmarkt. 

Bei diesen Benchmark-Durchläufen wird die gebenchmarkte Operation von 50 Threads jeweils 50.000 oder 500.000 Mal ausgeführt und gemessen. Wie häufig eine Operation von den Threads durchgeführt wird, hängt dabei von der Konfiguration des Parameters Messumfang ab. Beträgt dieser 2.500.000 so führen die Threads ihn jeweils 50.000 Mal durch. Nimmt er den Wert 25.000.000 an, wird die Operation 500.000 Mal von einem Thread verrichtet. 