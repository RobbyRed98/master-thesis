\chapter{Vorgehen}
\label{vorgehen}
Dieses Kapitel befasst sich mit der Methode und dem Aufbau, der für die Performance-Analyse von Db2 Graph und den Vergleich mit einem anderen Graphdatenbanksystem gewählt wurde. 

\section{Bezug zu anderen Arbeiten}
Bevor genauer auf die Methode der Performance-Analyse eingegangen werden kann, muss darauf hingewiesen werden, dass sich einige Elemente der Analyse, an dem Vorgehen einer anderen Arbeit orientieren. 

So wird in dem Paper \cite{sigmod_tian} ebenfalls eine Performance-Analyse mit Db2 Graph und anderen Datenbanksystemen durchgeführt. Da das Paper \cite{sigmod_tian} in einigen Teilen ähnliche Ziele wie diese Arbeit verfolgt, werden einige Aspekte der Performance-Analyse aus diesem Paper in diese Arbeit übernommen. 

So spiegeln die in \autoref{analyse:metriken} beschriebenen Metriken, die aus \cite{sigmod_tian} bekannten Metriken Latenz und Durchsatz wider.

Auch bei der Wahl des Linkbench Benchmark, fiel ins Gewicht, dass dieser bereits in \cite{sigmod_tian} für die Performance-Analyse von Db2 Graph eingesetzt wurde. Allerdings war dies nicht der entscheidende Faktor für die Wahl von Linkbench als Mittel zur Performance-Analyse in dieser Arbeit. Die Wahl von Linkbench als Benchmark wird dabei in \autoref{analyse:benchmark} im Detail begründet. 

Darüber hinaus muss darauf hingewiesen werden, dass es auch größere Unterschiede zwischen den Messungen im Kontext dieser Arbeit und denen von \cite{sigmod_tian} gibt. So unterscheiden sich die für die Messungen genutzten Db2 Graph Versionen und die Implementierung der Linkbench-Adapter. Außerdem setzt sich der für die Performance-Analyse genutzte Datensatz in \cite{sigmod_tian} anders zusammen, als alle in \autoref{analyse:messreihen} beschriebenen Messreihen dieser Arbeit.

\section{Benchmark}
\label{analyse:benchmark}
Der Benchmark Linkbench wurde nicht ausschließlich als Mittel für die Performance-Analyse gewählt, weil dieser auch in \cite{sigmod_tian} eingesetzt wurde. Stattdessen wurde der Benchmark aus folgenden Gründen ausgesucht:
\begin{itemize}
    \item Es handelt sich bei Linkbench um einen Benchmark für Graph-Daten.
    \item Der Workload des Benchmarks ist einer realen Arbeitslast nachempfunden, auch wenn er sich hauptsächlich auf OLTP-Operationen beschränkt, siehe \autoref{linkbench:operationen}. 
    \item Auf der Basis der elementaren Graph-Operationen lässt sich bereits eine Einordnung der Performance von Db2 Graph oder Systemen vornehmen. 
    \item Linkbench ist flexibel konfigurier- und erweiterbar, siehe \autoref{linkbench}. 
    \item Der Aufwand für die Implementierung eines Adapters für Db2 Graph wurde als im Rahmen dieser Arbeit möglich eingeschätzt.
\end{itemize}
Bevor der Linkbench Benchmark für die Performance-Analyse im Rahmen dieser Arbeit ausgewählt wurde, wurde auch der SNB-Benchmark als möglich Alternative gehandelt. Bei diesem  handelt es sich um einen deutlich neueren Benchmark für Graph-Daten als Linkbench \cite{snb_paper}. Dieser wurde vom LDBC-Projekt initiiert und entwickelt \cite{snb_paper}. Der Benchmark versucht dabei sowohl OLTP- als auch OLAP-Workloads abzubilden, anders als Linkbench der hauptsächlich OLTP-Operationen abdeckt \cite{snb_paper}. Die Wahl viel allerdings wie zuvor beschrieben auf Linkbench, da der Aufwand für die Anbindung von Db2 Graph an diesen Benchmark als geringer eingestuft wurde.  

\section{Vergleich}
\label{analyse:vergleich}
Um die Linkbench-Ergebnisse von Db2 Graph später im Rahmen der Analyse besser einordnen zu können, findet ein Vergleich der Db2 Graph Ergebnisse, mit denen von Neo4j statt. Dieses Datenbanksystem wurde hierbei als eine Art Referenzpunkt für die Performance von Db2 Graph gewählt, da es sich bei diesem um ein bekanntes natives Graphdatenbanksystem handelt \cite{gdbms}. Folglich ist Neo4j als Datenbanksystem auch in allen Messreihen vertreten, siehe \autoref{analyse:messreihen}.

\section{Implementierung}
\label{analyse:Implementierung}
Um eine Performance-Analyse für Db2 Graph Beta 3 und Db2 Graph V11.5.6.0 durchzuführen und ebenfalls Referenzwerte für Neo4j zu erhalten, müssen im Rahmen dieser Arbeit die folgenden vier Adapter für Linkbench implementiert werden:
\begin{itemize}
    \item \texttt{Neo4j}-Adapter für Neo4j,
    \item \texttt{Db2GraphOld}-Adapter für Db2 Graph Beta 3, 
    \item \texttt{Db2Graph}-Adapter für Db2 Graph V11.5.6.0 und
    \item \texttt{Db2}-Adapter.
\end{itemize}

Für Neo4j muss im Rahmen der Arbeit ein Adapter implementiert werden, da frei verfügbaren Linkbench-Neo4j-Adapter wie beispielsweise \cite{neo_linkbench_github} auf dem technischen Stand von 2013 sind. Daher sind diese Adapter nicht dazu in der Lage, die Fähigkeiten neuer Neo4j-Versionen auszuschöpfen. So wird in \cite{neo_linkbench_github} eine veraltete Java-basierte Traversal-API zur Interaktion mit Neo4j eingesetzt, obwohl inzwischen die Cypher-Abfragesprache die bevorzugte Form der Interaktion mit Neo4j ist \cite{gdbms}.

Eine eigene Adapter-Implementierung für Db2 Graph Beta 3 und Db2 Graph V11.5.6.0 ist hingegen ebenfalls notwendig, da Db2 Graph an sich eine neue Technologie darstellt, die erst seit einer kurzen Dauer auf dem Markt ist. Darüber hinaus handelt es sich bei den in \cite{sigmod_tian} für die Durchführung der Messungen eingesetzten Db2Graph-Linkbench-Adapter um die bisher einzige bekannte Implementierung eines solchen Adapters. Dieser Adapter wurde dabei allerdings für die Anbindung einer älteren Db2 Graph Version an Linkbench entwickelt und ist darüber hinaus nicht frei zugänglich.

Die Entwicklung von zwei verschiedener Adaptern für Beta 3 und V11.5.6.0 ist darüber hinaus auch nötig. Denn schließlich unterscheiden sich die Db2 Graph Versionen, wie in \autoref{db2graph:versionen} bereits erläutert, bezüglich des Verbindungsaufbaus und des Session-Managements. 

Bevor mit der Implementierung der Db2Graph-Linkbench-Adapter begonnen werden, kann wird im Rahmen dieser Arbeit allerdings ein Db2-Linkbench-Adapter entwickelt. Dieser dient dabei als Basis für die Db2Graph-Linkbench-Adapter. So müssen bei der Implementierung der Db2Graph-Linkbench-Adapter hauptsächlich die lesenden Operationen des Adapters überschrieben werden. Bei den schreibenden Operationen die beiden Db2 Graph Versionen nicht beherrschen, können die jeweiligen Adapter dann auf die Operationen des Db2-Linkbench-Adapters zurückgreifen, um diese direkt in Db2 Graph umzusetzen.

Weitere Details bezüglich der Implementierung werden in \todo{Referenz für Implementierungskapitel} erläutert.

\section{Operationen}
\label{analyse:operationen}
Für die Performance-Analyse der Datenbanksysteme werden im Rahmen dieser Arbeit die folgenden Operationen von Linkbench herangezogen:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink} und
    \item \texttt{getLinkList}.
\end{itemize}
Die Auswahl wurde getroffen, da Db2 Graph Beta 3 und v11.5.6.0 ausschließen lesende-Operationen unterstützen. Bei allen anderen Operationen die in \autoref{linkbench:operationen} aufgeführt werden handelt es sich jedoch um schreibende Operationen. Daher muss auf diese verzichtet werden. 

In \autoref{src:gremlin_queries} werden die Gremlin-Queries aufgeführt, die für das Benchmarking von Db2 Graph Beta 3 und Db2 Graph V11.5.6.0 eingesetzt wurden. 
\begin{lstlisting}[label=src:gremlin_queries,caption={ Gremlin Queries (regulär)},language=Java]
/* getNode */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID>);

/* getLink */
g.E()
 .hasLabel("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .has("ID1", <NODE_ID1>)
 .has("ID2", P.within(<NODE_ID2s>))

/* countLinks */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID>)
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .count()

/* getLinkList */
g.V()
 .hasLabel("NODETABLE")
 .has("ID", <NODE_ID1>)
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)
 .limit(<LIMIT>);
\end{lstlisting}

Für das Benchmarking von Neo4j wurden hingegen die  Cypher-Queries in \autoref{src:cypher_queries}. Neo4j unterstützt zwar auch Gremlin als Abfragesprache \cite{gdbms}. Allerdings handelt es sich bei Cypher um die bevorzugte Abfragesprache zur Interaktion mit Neo4j \cite{gdbms}.

\begin{lstlisting}[label=src:cypher_queries,caption={Cypher Queries (regulär)},language=CQL]
/* getNode */
MATCH (n:node{id: $id}) 
RETURN n.id AS ID, n.type AS TYPE, 
    n.version AS VERSION, n.time AS TIME, 
    n.data AS DATA

/* getLink */
MATCH (n1:node{id: $id1})-[l:link{link_type: $link_type}]->(n2:node) 
WHERE n2.id IN $id2s 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION

/* countLinks */
MATCH (:node{id: $id1})-
    [l:link{link_type: $link_type}]->
    (:node) 
RETURN COUNT(l) AS COUNT

/* getLinkList */
MATCH (n1:node{id: $id1})-
    [l:link{link_type: $link_type}]->
    (n2:node) 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION 
LIMIT $limit
\end{lstlisting}

Im Zuge der Performance-Analyse der Datenbanksysteme werden allerdings bei Messungen mit real-verteilten Datensätzen vier verschiedene Varianten der \texttt{getLinkList}-Operation eingesetzt. Darauf wird in im Detail eingegangen \autoref{analyse:parameter}.

\section{Metriken}
\label{analyse:metriken}
Bei den Messungen im Rahmen der Arbeit werden die folgenden Metriken herangezogen: 

\begin{itemize}
    \item Latenz und 
    \item Durchsatz.
\end{itemize}

Der Begriff Latenz bezeichnet dabei den Zeitraum zwischen dem Abschicken einer Anfrage an ein Datenbanksystem und dem Eintreffen der Antwort auf die Anfrage. Alternative könnte die Latenz auch als Verarbeitungszeit betrachtet werden. 

Unter der Metrik Durchsatz wird dabei erfasst, wie viele Operationen pro Sekunde im Durchschnitt während einer Messung durchgeführt werden. 

Darüber hinaus werden während jeder Messungen die Betriebssystemstatistiken erfasst. NMON zeichnet dabei einmal pro Minute einen Datenpunkt auf. Diese Statistiken werden hierbei nicht als eine weitere Metrik betrachtet. Die registrierten Daten können allerdings bei der Auswertung der Ergebnisse ergänzend hinzugezogen werden.

\section{Parameter}
\label{analyse:parameter}
Die Messungen die im Rahmen dieser Arbeit durchgeführt werden, können anhand von zwei Hauptparametern unterschieden werden:
\begin{itemize}
    \item die Verteilung / Struktur der Datensätze und 
    \item die Größe der Datensätze. 
\end{itemize}
Diese beiden Messparameter spielen hierbei im Kontext aller Messungen eine wichtige Rolle. 

Darüber hinaus gibt es noch die zwei Nebenparameter:
\begin{itemize}
    \item Ergebnismenge und 
    \item Query-Stil. 
\end{itemize}
Diese spielen hierbei entweder bei Messungen mit real- oder mit konstant-verteilten Datensätzen eine Rolle.  

\subsection{Verteilung}
Bei der Struktur der Datensätze kann zwischen den beiden folgenden Verteilungen unterschieden werden: 

\begin{itemize}
    \item \textit{konstante Verteilung}\\
    Hierbei besitzt jeder Knoten im Datensatz exakt dieselbe Anzahl an Kanten (Links) wie jeder andere Knoten. Im Rahmen dieser Arbeit wurde bei allen Messungen immer eine konstante 10er-Verteilung gewählt. Dies bedeutet das jeder Knoten genau 10 Kanten aufweist.  
    \item \textit{reale Verteilung}\\
    Hierbei ist die Verteilung von Kanten (Links) auf Knoten einer realen Verteilung eines Social-Graphs nachempfunden. Die Anzahl der Kanten, über die ein Knoten verfügt, bewegt sich dabei bei allen Messungen die in dieser Arbeit durchgeführt werden zwischen 2 und ca. 5.000.000. Dabei gibt es sehr viele Knoten mit einer geringen Anzahl an Kanten wie zwei und einzelne Knoten die mehr als 1.000.000 Kanten aufweisen. 
\end{itemize}

Die real-Verteilung wurde hierbei für die Messungen gewählt, da sie eine realitätsnahe Zusammensetzung eines Social-Graphs aufweist. Die Messergebnisse lassen somit Schlüsse darauf zu, wie sich das System bei solchen Workloads in der Praxis verhalten würde.

Die konstante Verteilung wurde entgegen der real-Verteilung nicht aufgrund ihrer Praxis-nähe für die Messungen ausgewählt. Stattdessen wurde Sie für die Messungen herangezogen, da Db2 Graph Beta 3 bei ersten Versuchen Schwierigkeiten mit einer hohen Kantenzahl in real-Verteilten Datensätzen aufwies. Das Benchmarking der \texttt{getLinkList}-Operation verursachte hierbei früher oder später einen beinahe Stillstand des Benchmark-Durchlaufs. 

Dieses Verhalten kann hierbei damit begründet werden, dass sich Db2 Graph Beta 3 damit schwertut, mit großen Ergebnismengen von über 100.000 Kanten je Knoten zu arbeiten. Darüber hinaus kann dieses Problem von Db2 Graph Beta 3 mit real-verteilten Datensätzen auch nicht durch die Begrenzung der Ergebnismenge im Rahmen der Gremlin-Query gelöst werden. Schließlich beherrscht Db2 Graph Beta 3 die Optimierungstechnik \textit{Limit Pushdown} nicht, siehe \autoref{db2graph:optimierung}. 

Aufgrund dessen und da es nachvollziehbarer Weise nicht zielführend wäre, die maximale Kanten auf Knoten Verteilung eines real-verteilten Datensatzes zu verändern, wurde auch entschieden, konstant-verteilte Datensätze als Teil der Messungen mit aufzunehmen. Schließlich ergibt sich dadurch die Möglichkeit Messergebnisse für Db2 Graph Beta 3 zu erzielen und diese mit V11.5.6.0 und Neo4j zu vergleichen. Allerdings nur unter der Voraussetzung, dass eine kleine konstante Verteilung gewählt wird, wie die konstante 10er-Verteilung. 

Außerdem gilt es hierbei noch anzumerken, dass es keine Messungen von Db2 Graph Beta 3 und real-verteilten Datensätzen im Rahmen dieser Arbeit erfolgen. Da des zuvor angesprochenen Problems von Db2 Graph Beta 3 mit derart verteilten Datensätzen.

\subsection{Größe}
Dieser Hauptparameter wurde dabei für die Messungen gewählt, um herauszufinden, wie sich die Datenbanksysteme beim Umgang mit kleineren (Linkbench-10M) und größeren (Linkbench-100M) Datensätzen verhalten. 

Hierbei wird in dieser Arbeit zwischen Datensätzen mit der Knoten Anzahl 10 Millionen und 100 Millionen unterschieden. Angelehnt an \cite{sigmod_tian} werden die Messergebnisse für die verschiedenen Knotenzahlen hier auch als:
\begin{itemize}
    \item Linkbench-10M für 10 Millionen Knoten und 
    \item Linkbench-100M für 100 Millionen Knoten bezeichnet.
\end{itemize}
Dadurch fällt die Unterscheidung zwischen den beiden Größenordnungen leichter. 

Dabei muss allerdings im Auge behalten werden, dass sich die Größe der Datenmengen je nach Verteilung eines Datensatzes weiterhin unterscheiden kann. Schließlich verfügen die Datensätze bei gleicher Knoten Anzahl über unterschiedlich viele Kanten, siehe \autoref{tab:kanten_anzahl}. So weisen in \autoref{tab:kanten_anzahl} konstant verteilte Datensätze fast die doppelte Anzahl an Kanten auf, wie real-verteilte Datensätze, bei der identischen Konfiguration Größen-Parameters. 

\begin{table}[ht]
    \centering
    \begin{tabular}{l|r|r}
    \hline
    \rowcolor[HTML]{EFEFEF} 
    \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Verteilung}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-10M}} & \multicolumn{1}{c}{\cellcolor[HTML]{EFEFEF}\textbf{Linkbench-100M}} \\ \hline
    real & ca. 53.000.000 Kanten & ca. 530.000.000 Kanten \\
    konstant & 100.000.000 Kanten & 1.000.000.000 Kanten \\ \hline
    \end{tabular}
    \caption{Übersicht Linkbench Kantenanzahl}
    \label{tab:kanten_anzahl}
    \vspace{1em}
    \textit{}
\end{table}

Aufgrund dessen sollte auch später vom Vergleich der Messergebnisse zwischen den unterschiedlich verteilten Datensätzen bei Linkbench-10M und Linkbench-100M abgesehen werden.

\subsection{Ergebnismenge}
Dieser Parameter regelt bei den Messungen mit real-verteilten Datensätzen, wie groß die Ergebnismenge bei der \texttt{getLinkList}-Operation maximal werden kann. Konkret legt der Parameter dabei fest, wie viele Kanten maximal Teil der Ergebnismenge einer \texttt{getLinkList}-Operation sein können.

Durch die Variation des Parameters kann hierbei ermittelt werden, wie sich die Größe der Ergebnismengen, auf die Performance der Datenbanksysteme auswirkt. 

Die Beschränkung der Ergebnismenge wird dabei in der Linkbench-Workload-Konfiguration vorgenommen. Für die Konfiguration muss dort der Wert für \texttt{range\_limit} angepasst werden. 

Dieser Parameter wird dabei als Bestandteil aller Messungen bei real-verteilten Datensätzen herangezogen. Schließlich sind bei diesen auch größere Ergebnismengen möglich. Das Limit der Ergebnismenge bei der \texttt{getLinkList}-Operation variiert bei diesen Messungen immer zwischen: 
\begin{itemize}
    \item 100,
    \item 1.000,
    \item 10.000 und
    \item 100.000.
\end{itemize}

So werden bei den Messungen mit Bezug zu real-verteilten Datensätzen statt der vier regulären, die folgenden sieben Operationen gebenchmarkt:
\begin{itemize}
    \item \texttt{getNode},
    \item \texttt{getLink},
    \item \texttt{countLink},
    \item \texttt{getLinkList(100)},
    \item \texttt{getLinkList(1.000)},
    \item \texttt{getLinkList(10.000)} und
    \item \texttt{getLinkList(100.000)}.
\end{itemize}

Der Wert in der Klammer bei der \texttt{getLinkList}-Operation gibt dabei das Limit für die Ergebnismenge an. So nehmen die Platzhalter \texttt{<LIMIT>} und \texttt{\$limit}
in \autoref{src:gremlin_queries} und \autoref{src:cypher_queries} bei der \texttt{getLinkList}-Operation die zuvor aufgeführten Werte an, im Rahmen der Messungen.

\subsection{Query-Stil}
Der Query-Stil stellt einen weiteren Parameter Nebenparameter dar. Dabei wird zwischen sogenannten regulären Queries und ID-Queries unterschieden. 

Bei den regulären Queries handelt es sich um die Anfragen, die bereits in \autoref{src:gremlin_queries} und \autoref{src:cypher_queries} aufgeführt wurden. Die Queries werden als reguläre Queries bezeichnet, da sie nahezu Bestandteil aller Messreihen sind, auf diese wird in \autoref{analyse:messreihen} weiter eingegangen. 

Die sogenannten ID-Queries unterscheiden sich bezüglich der Logik der Abfrage nur geringfügig von sogenannten regulären Queries. Allerdings werden die Gremlin-Queries anders formuliert als bei den regulären Queries. So nutzen die Gremlin ID-Queries in \autoref{src:gremlin_id_queries} eine Gremlin-ID -- ähnlich der \texttt{vid} oder \texttt{eid} von Db2 Graph in \autoref{db2graph:funktionsweise} -- um einen bestimmten Knoten oder Kante direkt im ersten Schritt herauszufiltern. Dies ist in \autoref{src:gremlin_id_queries} daran erkennbar, dass dort parametrisierte Versionen der Steps \texttt{V()} und \texttt{E()} zum Einsatz kommen. Dabei wird zu Beginn auf die für die regulären Queries typischen \texttt{has}- und \texttt{hasLabel}-Steps verzichtet.

\begin{lstlisting}[label=src:gremlin_id_queries,caption={Gremlin ID-Queries},language=Java]
/* getNode */
g.V(["NODETABLE",<NODE_ID>]);

/* getLink */
g.E(["LINKTABLE", <NODE_ID1>, <NODE_ID2>, <LINK_TYPE>])

/* countLinks */
g.V(["NODETABLE",<NODE_ID1>])
 .outE("LINKTABLE")
 .has("LINK_TYPE", <LINK_TYPE>)

/* getLinkList */
g.V(["NODETABLE",<NODE_ID1>])
 .outE("LINKTABLE")
 .has("LINK_TYPE",  <LINK_TYPE>)
 .limit(<LIMIT>)
\end{lstlisting}

Die Logik zwischen den regulären und ID-Queries unterscheidet sich, wie zuvor erwähnt lediglich geringfügig. Dies beutet das alle Queries dieselben Informationen abfragen, außer bei der \texttt{getLink}-Operation. Während bei dieser Operationen bei den regulären Queries eine Menge an IDs (\texttt{<NODE\_ID2s>}) für den Endknoten genutzt werden, so wird bei den ID-Queries ausschließlich eine ID (<NODE\_ID2>) herangezogen. 

Aufgrund dessen und da der Hauptunterschied zwischen den Query-Stilen den Aufbau der Gremlin-Queries betrifft, muss bei den Cypher ID-Queries lediglich die \texttt{getLink}-Operation wie in \autoref{src:cypher_id_queries} dargestellt
angepasst werden. Dies ist notwendig, um sicherzustellen, dass die Gremlin und Cypher ID-Queries dieselbe Abfragelogik aufweisen und somit dieselben Informationen abfragen. 
\begin{lstlisting}[label=src:cypher_id_queries,caption={Cypher ID-Queries},language=CQL]
/* getLink */
MATCH (n1:node{id: $id1})-[l:link{link_type: $link_type}]->(n2:node{id: $id2}) 
RETURN n1.id AS ID1, n2.id AS ID2, 
    l.link_type AS LINK_TYPE, 
    l.visibility AS VISIBILITY, 
    l.data AS DATA, l.time AS TIME, 
    l.version AS VERSION,
\end{lstlisting}

\section{Umgebung}
\label{analyse:umgebung}
Für alle Messungen, die Teil der Performance-Analyse sind, wird im Rahmen der Arbeit derselbe Server herangezogen. Bei diesem handelt es sich um einen Ubuntu-Server 20.04.2 LTS mit folgenden Charakteristika:
\begin{itemize}
    \item 32 CPUs (AMD EPYC 7502P), 
    \item 256 GB Arbeitsspeicher,
    \item 500 GB SSD-Hauptspeicher,
    \item \texttt{ext4} als Dateisystem und 
    \item dem Linux-Kernel \texttt{5.4.0-77-generic}.
\end{itemize}
Des Weiteren gilt es dabei herauszustellen, dass die folgenden Datenbanksysteme während Messungen alle als Docker-Container betrieben werden: 
\begin{itemize}
    \item Db2,
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}
Jedes dieser Systeme wird in einem eigenen Container betrieben. 

\section{Datenbanksysteme}
\label{analyse:datanbanksysteme}
Im Rahmen der Performance-Analyse werden Messungen mit den folgenden Datenbanksystemen durchgeführt: 
\begin{itemize}
    \item Db2 Graph Beta 3 (+ Db2),
    \item Db2 Graph V11.5.6.0 (+ Db2) und
    \item Neo4j.
\end{itemize}
In den folgenden Unterabschnitten werden dabei die wichtige Anwendungs- be\-zieh\-ungs\-wei\-se System-Konfigurationen beschrieben. 

\subsection{Db2}
Die beiden Db2 Graph Versionen verwenden im Rahmen der Performance-Analyse bei allen Messungen dieselbe Db2 Instanz. Dadurch wird gewährleistet, dass beide auf ein relationales Datenbankmanagementsystem zugreifen, das sich nicht in der Konfiguration zwischen den Db2 Graph Versionen unterscheidet. Außerdem können somit beide Db2 Graph Versionen auf Basis eines identischen Datensatzes operieren. Auf diese Weise kann eine Verzerrung der Messergebnisse vermieden werden und beide Versionen von Db2 Graph arbeiten während des Benchmarking unter denselben Voraussetzungen.

Bei der Db2 Instanz, die von beiden Db2 Graph Versionen genutzt wird, handelt es sich um die Db2 Advanced Edition in Version v11.5.5.1. Per Konfiguration wurden ihr 180 GB an Arbeitsspeicher zugewiesen. Darüber hinaus verfügt sie über die für Linkbench benötigte Datenbank \texttt{linkdb0}. Diese weist im Kontext aller Messungen das in \autoref{src:linkdb0_schema} beschrieben Datenbankschema auf:

\begin{lstlisting}[label=src:linkdb0_schema,caption={Db2 Instanz Datenbankschema für linkdb0},language=SQL]
CREATE TABLE linkdb0.nodetable
(
    id      bigint NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1),
    type    int       NOT NULL,
    version numeric   NOT NULL,
    time    int       NOT NULL,
    data    clob(48000)  NOT NULL,
    PRIMARY KEY (id)
) ORGANIZE BY ROW COMPRESS YES;

CREATE TABLE linkdb0.linktable
(
    id1        bigint  NOT NULL DEFAULT '0',
    id2        bigint  NOT NULL DEFAULT '0',
    link_type  bigint  NOT NULL DEFAULT '0',
    visibility smallint     NOT NULL DEFAULT '0',
    data       varchar(255) NOT NULL DEFAULT '',
    time       bigint  NOT NULL DEFAULT '0',
    version    bigint       NOT NULL DEFAULT '0',
    PRIMARY KEY (link_type, id1, id2)
) ORGANIZE BY ROW COMPRESS YES;

/* Exisitiert, wird aber nicht genutzt. */
CREATE TABLE linkdb0.counttable
(
    id        bigint NOT NULL DEFAULT '0',
    link_type bigint NOT NULL DEFAULT '0',
    count     int         NOT NULL DEFAULT '0',
    time      bigint NOT NULL DEFAULT '0',
    version   bigint NOT NULL DEFAULT '0',
    PRIMARY KEY (id, link_type)
) ORGANIZE BY ROW COMPRESS YES;
\end{lstlisting}

An dem in \autoref{src:linkdb0_schema} beschriebenen Schema kann dabei abgelesen werden, dass alle Tabellen adaptive Kompression nutzen. Darüber hinaus existiert in \autoref{src:linkdb0_schema} eine Count-Tabelle (\texttt{linkdb0.counttable}) die von den Linkbench-Adaptern für Db2 Graph Beta 3 und V11.5.6.0 nicht genutzt wird. Sie ist lediglich vorhanden, da Linkbench ihre Existenz voraussetzt. 

Neben dem Datenbankschema von \texttt{linkdb0} muss auch noch darauf hingewiesen werden, dass die Datenbank einen Bufferpool (\texttt{IBMDEFAULTBP}) der Größe 163,920 GB nutzt. Der Bufferpool besteht dabei aus exakt 40.000.000 Seiten, mit einer Seitengröße (\texttt{PAGESIZE}) von 4096 Byte.

\subsection{Db2 Graph}
Die Version Beta 3 und V11.5.6.0 von Db2 Graph verfügen im Rahmen der Performance-Analyse eine vergleichbare Konfiguration. Lediglich die in V11.5.6.0 neu eingeführte \texttt{db2graph-server.yaml} und \texttt{db2graph-internal.yaml} sorgen dafür, dass es Konfigurationsunterschiede zwischen beiden Versionen gibt. Auf diese beiden Konfigurationen wird allerdings nicht näher eingegangen. Schließlich wurden die beiden Konfigurationen nicht für die Messungen angepasst. Somit wird im Rahmen der Performance-Analyse die mit Db2 Graph V11.5.6.0 ausgelieferte Standard-Konfiguration von \texttt{db2graph-server.yaml} und \texttt{db2graph-internal.yaml} her\-angezogen.

Die \texttt{gremlin-server.yaml} Konfiguration sowie die Ressourcen-Parameter des Gremlin-Servers von Db2 Graph Beta 3 und V11.5.6.0 wurde beide allerdings gleichermaßen für die Messungen angepasst. Unter diese Anpassungen fallen:
\begin{itemize}
    \item \textit{Gremlin-Memory}\\
    Dieser Ressourcen-Parameter legt fest wie viel Memory der Gremlin-Server des TinkerPop-Stacks im maximal Fall nutzen kann. Der Standard-Wert beträgt hier bei beiden Db2 Graph Versionen normalerweise 4 GB. Um eine möglichst hohe Performance mit beiden Db2 Graph Versionen zu erzielen wurde das Memory-Limit für den Gremlin-Server im Rahmen der Messungen allerdings auf 64 GB angehoben. 
    \item \textit{Thread-Pool-Worker}\\
    Der Wert für Thread-Pool-Worker regelt, wie viele Threads für die Verarbeitung von nicht-blockenden Operationen im Gremlin-Server bereitstehen \cite{tinkerpop_2020}. Der Wert ist dabei normalerweise auf 0 gesetzt, was zur Folge hat, das die Anzahl von verfügbaren Prozessoren herangezogen wird \cite{tinkerpop_2020}. Dies hätte im Rahmen der Messumgebung zur Folge, dass die Thread-Pool-Worker standardmäßig auf 32 gesetzt werden würden. 
    
    Um eine möglichst hohe Performance für die Db2 Graph Versionen bei den Messungen zu gewährleisten, wurde der Wert allerdings auf 128 erhöht. Da es dadurch den Gremlin-Server dahingehen unterstützt, große Lasten besser zu verarbeiten. So ist es dem Gremlin-Server dadurch möglich 50 oder 100 Anfragen, die von den entsprechenden Linkbench-Threads während des Benchmarking gesendet werden, auf einmal zu bearbeiten. 
    \item \textit{Gremlin-Pool}\\
    Der Wert für den Gremlin-Pool spezifiziert, wie viele Threads dem Gremlin-Server für die Verarbeitung von blockenden Operationen zur Verfügung stehen \cite{tinkerpop_2020}. Ähnlich wie Thread-Pool-Worker zieht er in der Standard-Konfiguration die verfügbare Prozessoranzahl (32) heran \cite{tinkerpop_2020}. Um eine höhere Performance zu erreichen, wurde er allerdings ebenfalls auf 128 erhöht. 
    
    Die Erhöhung wurde hierbei allerdings lediglich als eine Art Vorsichtsmaßnahme durchgeführt. Schließlich unterstützt Db2 Graph lediglich lesende Queries. Dies hat zur Folge, dass der Gremlin-Server eigentlich nicht auf blockende Operationen zurückgreifen sollte. Allerdings ist nicht bekannt, ob Db2 Graph in der Praxis wirklich nur auf nicht-blockende Operationen zurückgreift. Daher wurde der Wert des Gremlin-Pools analog zu Thread-Pool-Worker angehoben. 
\end{itemize}

Beide Versionen von Db2 Graph nutzen darüber hinaus die in \autoref{src:db2graph_mapping} dargestellte Graph-Overlay-Konfiguration, zum Mapping der in \autoref{src:linkdb0_schema} beschrieben Tabellen auf eine Graphstruktur. Hierbei wird die \texttt{linkdb0.nodetable} aus \autoref{src:linkdb0_schema} als Vertex-Tabelle in \autoref{src:db2graph_mapping} herangezogen, während die \texttt{linkdb0.linktable} die Rolle einer Edge-Tabelle übernimmt. 
\begin{lstlisting}[label=src:db2graph_mapping,caption={Graph-Overlay-Konfiguration Db2 Graph},language=json]
...
"jdbc_num_conn": 100,
"v_tables": [
    {
        "vid": {
            "prefix": "LINKDB0.NODETABLE",
            "id_cols": [
                "ID"
            ]
        },
        "table_id": "LINKDB0.NODETABLE",
        "table": {
            "schema_name": "LINKDB0",
            "table_name": "NODETABLE"
        },
        "label": {
            "fixed_label": true,
            "label": "NODETABLE"
        }
    }
],
"e_tables": [
    {
        "src_v_cols": [
            "ID1"
        ],
        "dst_v_cols": [
            "ID2"
        ],
        "src_v_tables": [
            "LINKDB0.NODETABLE"
        ],
        "dst_v_tables": [
            "LINKDB0.NODETABLE"
        ],
        "eid": {
            "implicit_id": false,
            "id": {
                "prefix": "LINKDB0.LINKTABLE",
                "id_cols": [
                    "LINK_TYPE",
                    "ID1",
                    "ID2"
                ]
            }
        },
        "table_id": "LINKDB0.LINKTABLE",
        "table": {
            "schema_name": "LINKDB0",
            "table_name": "LINKTABLE"
        },
        "label": {
            "fixed_label": true,
            "label": "LINKTABLE"
        }
    }
]
\end{lstlisting}

\subsection{Neo4j}
Alle Messungen die im Rahmen der Performance-Analyse durchgeführt werden, nutzen dieselbe Neo4j-Instanz. Bei dieser Instanz handelt es sich um die Community-Edition von Neo4j in Version 4.3. An der Konfiguration von Neo4j ändert sich zwischen den verschiedenen Messreihen nichts. Sie weist somit immer dieselbe Konfiguration auf. Bei dieser Konfiguration gilt es die folgenden Parameter hervorzuheben: 
\begin{itemize}
    \item 160 GB Page Cache und
    \item maximaler JVM Heap 64 GB.
\end{itemize}
Der Page Cache kann hierbei als das Neo4j-Pendant zum Bufferpool von Db2 betrachtet werden. Daher wurde mit ca. 164 GB und 160 GB auch eine vergleichbare Konfiguration für beide gewählt. Der JVM Heap in Neo4j und der Gremlin-Memory von Db2 Graph wurden hierbei aufgrund ihrer ähnlichen Funktion ebenfalls als vergleichbar angesehen, weshalb beide auf 64 GB gesetzt wurden.

Bei Neo4j handelt es sich um eine native Graphdatenbank, die auf dem in \autoref{datenmodelle} beschrieben Graphmodell basiert. Dadurch unterstützt Neo4j ein flexibles Datenbankschema, wie in \autoref{datenmodelle:structure}bereits beschrieben. Neo4j unterstützt allerdings trotz des flexiblen Schemas die Definition von Constraints. Ein solcher Constraint und ein Index werden hierbei in den Graphdatenbank eingerichtet, um einen fairen Vergleich von zwischen den Db2graph Versionen (+ Db2) und Neo4j zu ermöglichen. Der in \autoref{src:neo4j_schema} beschriebene Constraint und Index werden hierbei eingeführt, um dafür zu sorgen, dass ähnliche Indexe wie in Db2 auch in Neo4j existieren. Schließlich werden in Db2 beim Anlegen eines Primärschlüssels automatisch Indexe für dessen Bestandteile erzeugt. Zum Ausgleich werden daher die \autoref{src:neo4j_schema} spezifizierten Konstrukte angelegt. Der Constraint in \autoref{src:neo4j_schema} sorgt dabei dafür, dass keine Knoten mit dem Label \texttt{node}, dieselbe ID aufweisen können. Zugleich wird im Zuge dessen auch ein Index auf die ID von \texttt{node}-gelabelten Knoten erstellt.

\begin{lstlisting}[label=src:neo4j_schema,caption={Neo4j Instanz Datenbankschema},language=CQL]
// Constraint aehnlich einem Primaerschluessel fuer Knoten
CREATE CONSTRAINT unique_node_id 
ON (n:node) ASSERT n.id IS UNIQUE;

// Index fuer die Kanten-Property link_type
CREATE INDEX link_type_index 
FOR ()-[l:link]-() 
ON (l.link_type);
\end{lstlisting}

\section{Messreihen}
\label{analyse:messreihen}
Die im Rahmen dieser Arbeit durchgeführten Messungen werden auf Basis einer bestimmten Konfiguration der Parameter aus \autoref{analyse:parameter} in Messreihen eingeteilt. Die Zusammensetzung dieser Messreihen werden dabei im Rahmen dieses Abschnitts beschrieben. 

Bevor damit allerdings begonnen werden kann, werden hier nochmals kurz die Parameter und Konfigurationen zusammengefasst, die über alle Messreihen hinweg konstant bleiben:
\begin{itemize}
    \item \textit{Umgebung}\\
    In der in \autoref{analyse:umgebung} beschrieben Umgebung, werden alle Messreihen durchgeführt. 
    \item \textit{Linkbench-Threads}\\
    Linkbench arbeitet in der Request-Phase immer mit 50 Threads die gleichzeitig Anfragen an ein Datenbanksystem schicken.
    \item \textit{Db2 Datenbankschema}\\
    Das Db2-Datenbankschema von \texttt{linkdb0} aus \autoref{src:linkdb0_schema} wird zwischen den Messreihen nicht verändert oder angepasst. 
    \item \textit{Konfiguration Db2 Graph Beta 3 \& V11.5.6.0}\\
    Die Graph-Overlay-Konfiguration in \autoref{src:db2graph_mapping} und die Gremlin-Server-Konfiguration der Db2 Graph Versionen bleiben über alle Messungen hinweg unverändert.
    \item \textit{Konfiguration \& Datenbankschema Neo4j}\\
    Die in Konfiguration von Neo4j und das bei den Messungen eingesetzte Datenbankschema \autoref{src:neo4j_schema} bleiben über die Messreihen hinweg unverändert. 
\end{itemize}

In den folgenden Unterabschnitten werden nun die verschiedenen Messreihen genauer erläutert. Der Name einer Reihe setzt sich dabei aus dem Namen des Benchmarks (Linkbench), der Abkürzung für die gewählte Verteilung (Const oder Real) des Datensatzes und der Größe des Datensatzes (10M oder 100M) zusammen. Falls bei einer Messreihe ID-Queries statt den regulären Queries zum Einsatz kommen, wird abschließend noch ID angehängt.

\subsection{Linkbench-Const-10M}
Im Rahmen dieser Messreihe werden Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j durchgeführt. 
\end{itemize}
Die Messungen werden dabei auf Basis der folgenden Eigenschaften beziehungsweise Parameter durchgeführt:
\begin{itemize}
    \item reguläre Queries,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Wie bei den Parametern beschrieben werden im Rahmen dieser Messreihe die regulären Queries herangezogen. Der für die Messungen erzeugte Datensatz besteht hingegen aus 10 Millionen Knoten und 100 Millionen Kanten. Darüber hinaus weist er eine konstante 10er-Verteilung auf. Das bedeutet jeder Knoten verfügt über exakt 10 ausgehende Kanten. 

Der Parameter Ergebnismenge beziehungsweise, dessen Variation, spielt im Kontext der Messreihe keine Rolle. So wird der Parameter bei allen Messungen der \texttt{getLinkList}-Operation auf 10.000 beschränkt. In der Praxis sollte diese Beschränk\-ung jedoch nie zum Einsatz kommen. Denn aufgrund der konstanten 10er-Verteilung des Datensatzes, weist jeder Knoten immer exakt 10 Kanten auf. Dies hat zur Folge, dass die Ergebnismenge im Maximalfall aus diesen 10 Kanten bestehen kann. 

\subsection{Linkbench-Const-10M-ID}
Teil dieser Messreihe sind Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Zugleich finden allen Messungen im Rahmen der Messreihe auf der Basis der folgenden Haupt- und Nebenparameter statt:
\begin{itemize}
    \item Queries-ID,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Die Messreihe ähnelt in ihrer Beschaffenheit der Messreihe Linkbench-Const-10M. Der Datensatz bei den Messungen weist eine konstante 10er-Verteilung auf und setzt sich aus 10 Millionen Knoten und 100 Millionen Kanten zusammen. Die Beschränkung der Ergebnismenge spielt ebenfalls keine Rolle. 

Lediglich der Query-Stil unterscheidet sich von dem von  Linkbench-Const-10M. So werden bei den Messungen im Rahmen dieser Reihe, die ID-Queries statt der regulären Queries herangezogen. Es handelt sich hierbei um die einzige Messreihe im Rahmen der Arbeit, bei der dies der Fall ist.

\subsection{Linkbench-Const-100M}
Im Kontext dieser Reihe erfolgen Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph Beta 3,
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Hierbei werden folgende Parameter bei allen Messungen herangezogen:
\begin{itemize}
    \item reguläre Queries,
    \item konstante Verteilung (Datensatz) und
    \item Linkbench-100M (Datensatzgröße).
\end{itemize}
Bei allen Messungen, die Teil dieser Messreihe sind, wird ein konstant (10) verteilter Datensatz eingesetzt, welcher 100 Millionen Knoten und 1 Milliarde Kanten umfasst. Des Weiteren kommen bei diesen Messungen die regulären Queries zum Einsatz. 

Die Ergebnismenge als Parameter spielt im Rahmen dieser Reihe aus denselben Gründen wie bei Linkbench-Const-10M und Linkbench-Const-10M-ID keine Rolle.

\subsection{Linkbench-Real-10M}
Bei dieser Messreihe werden Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j durchgeführt. 
\end{itemize}

Die Messungen im Rahmen dieser Messreihe werden dabei mit folgenden Parametern durchgeführt:
\begin{itemize}
    \item reguläre Queries,
    \item variierende Beschränkung der Ergebnismenge,
    \item reale Verteilung (Datensatz) und 
    \item Linkbench-10M (Datensatzgröße).
\end{itemize}
Bei den im Kontext der Reihe durchgeführten Messungen werden demnach die regulären Queries eingesetzt. Außerdem wird bevor die Messungen vorgenommen werden können, ein Datensatz mit einer realen Verteilung erzeugt. Dieser erzeugte Datensatz, welcher für das Benchmarking der Datenbanksysteme herangezogen wird, setzt sich dabei aus 10 Millionen Knoten und ca. 53 Millionen Kanten zusammen. Darüber hinaus werden im Rahmen der Messreihe, die Beschränkung der Ergebnismenge, das auch als Range-Limit bezeichnet wird, variiert. So gibt es Messungen mit dem regulären Range-Limit von 100 und 1.000, 10.000 sowie 100.000.

\subsection{Linkbench-Real-100M}
Teil dieser Reihe sind Messungen mit den Datenbanksystemen:
\begin{itemize}
    \item Db2 Graph V11.5.6.0 und 
    \item Neo4j. 
\end{itemize}

Außerdem finden allen Messungen im Kontext der Messreihe auf der Basis der folgenden Haupt- und Nebenparameter statt:
\begin{itemize}
    \item reguläre Queries,
    \item variierende Beschränkung der Ergebnismenge,
    \item reale Verteilung (Datensatz) und
    \item Linkbench-100M (Datensatzgröße).
\end{itemize}
Die Messreihe ähnelt hier im Aufbau der Linkbench-Real-10M Reihe stark. So werden bei dieser ebenfalls reguläre Queries eingesetzt, es werden mehrere Messungen für die \texttt{getLinkList}-Operation durchgeführt, mit variierendem Range-Limit und der Datensatz auf dem die Messungen basieren ist real verteilt. Allerdings umfasst der hierbei verwendete Datensatz 100 Millionen Knoten und ca. 530 Millionen Kanten, statt den 10 Millionen Knoten und ca. 53 Millionen Kanten bei der Messreihe Linkbench-Real-10M.

\todo{Anfrage-/Messmenge als Parameter Einführen}

\todo{Überblick Einführen}

\todo{Hierarchie Transformieren}