\chapter{Diskussion}
\label{diskussion}
Im Rahmen der Performance-Analyse und des Vergleichs von Db2 Graph (Beta 3 und V11.5.6.0) als hybridem Graphdatenbanksystem mit Neo4j als nativem Graphdatenbanksystem wurde festgestellt, dass Neo4j eine sechs- bis siebenfach höhere Performance aufweist als Db2 Graph. Des Weiteren wurde ein signifikanter Performance-Unterschied zwischen Db2 Graph Beta 3 und V11.5.6.0 identifiziert, dessen Ursprung im Rahmen der Arbeit nicht geklärt werden konnte. Dabei wies Db2 Graph Beta 3 bei einigen Messungen eine höhere Performance auf als die neuere Version V11.5.6.0, obwohl V11.5.6.0 nachweisbar den performanteren SQL-Code zur Abfrage von Db2 erzeugte. Außerdem konnte das eigentliche Ziel, der Reproduktion der Messergebnisse aus \cite{sigmod_tian} nicht erfüllt werden, da sich diese aufgrund einer fehlenden Spezifikation mehrere Aspekte der Messungen nicht reproduzieren ließen. 

Die im Rahmen der Arbeit erzielten Ergebnisse für die Performance von Db2 Graph und Neo4j weichen daher auch erheblich von denen in \cite{sigmod_tian} beschriebenen Messergebnissen ab. So bewegen sich beispielsweise die Performance-Ergebnisse in \cite{sigmod_tian} bei den durchschnittlichen Latenzen in anderen Größenordnungen als bei den hier erzielten Ergebnissen. Dies lässt sich möglicherweise darauf zurückführen, dass bei den Messungen in \cite{sigmod_tian} ein nicht von Linkbench generierter Datensatz oder eine andere Version von Db2 Graph herangezogen wird. Auf Basis der im Rahmen dieser Arbeit erzielten Messergebnisse lässt sich allerdings festhalten, dass Db2 Graph -- egal ob Beta 3 oder V11.5.6.0 -- bei allen Messungen nicht mit der Performance von Neo4j mithalten kann. Dies ist in der Retrospektive, wenn die Ergebnisse von \cite{sigmod_tian} außer Acht gelassen werden, jedoch nicht besonders überraschend. Schließlich handelt es sich bei Db2 Graph als Anwendung lediglich um eine Grapherweiterung für Db2, ein relationales Datenbanksystem, das nicht für den Umgang mit Graphdaten und -Queries optimiert ist. 

Es gilt hier allerdings auch herauszustellen, dass Db2 Graph trotz seiner geringeren Performance im Vergleich zu Neo4j beeindruckendes leistet. Es bietet schließlich die Möglichkeit, die Informationen in einer Db2-Datenbank, auf eine Graphstruktur zu mappen, ohne das Änderungen am Datenbankschema in Db2 vorgenommen werden müssen. So kann aus den Ergebnissen dieser Arbeit geschlussfolgert werden, dass Db2 Graph in Kombination mit Db2 als hybrides Graphdatenbanksystem nicht mit Neo4j mithalten kann, allerdings als Grapherweiterung für Db2 nicht desto trotz einen Mehrwert erbringt. 

Bei der Bewertung und Einordnung der Arbeit selbst gilt es zu beachten, dass die bei der Performance-Analyse erzielten Ergebnisse aufgrund der von Linkbench unterstützten Operationen hauptsächlich OLTP-Prozesse abbilden. Dadurch wird der Fokus dieser Arbeit auf grundlegende Operation wie \texttt{getNode} oder \texttt{getLink}, die Knoten und Kanten in einem Graphen abfragen, gelegt. Komplexere OLAP-Prozesse werden allerdings nicht berücksichtigt, da dies den Rahmen er Arbeit überschreiten würde. 

Des Weiteren wird bei den Messungen ein einfaches Datenschema genutzt, bei dem Knoten und Kanten in Db2 in einer Node- und einer Link-Tabelle abgelegt werden, während alle Knoten und Kanten in Neo4j jeweils als \texttt{node} oder \texttt{link} gelabelt werden. Dieses einfache Schema teilt dabei, wie bei relationalen Datenbanksystemen üblich, die Daten in die Entitätstypen Node und Link ein und hält oder labelt sie dementsprechend. Ob es sich hierbei allerdings um das einzige Schema handelt, dass für die Performance-Analyse von Neo4j und Db2 Graph geeignet ist hingegen unklar. Schließlich wäre an dieser Stelle auch ein am Graphmodell orientiertes Schema denkbar, bei dem die Nodes und Links auf Basis ihres \texttt{TYPE} und \texttt{LINK\_TYPE} in verschiedene Tabellen eingeordnet oder gelabelt werden. Auf das Datenbankschema in Db2 würde sich dies dabei wie in \autoref{src:linkdb0_schema_graph_style} beschrieben auswirken. 

\begin{lstlisting}[label=src:linkdb0_schema_graph_style,caption={Alternatives Datenbankschema für Db2},language=SQL]
CREATE TABLE linkdb0.nodetable_<TYPE_0>
(
    id      bigint NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1),
    version numeric   NOT NULL,
    time    int       NOT NULL,
    data    clob(48000)  NOT NULL,
    PRIMARY KEY (id)
) ORGANIZE BY ROW COMPRESS YES;

CREATE TABLE linkdb0.nodetable_<TYPE_1>(
    ...
) ORGANIZE BY ROW COMPRESS YES;

...

CREATE TABLE linkdb0.linktable_<LINK_TYPE_0>
(
    id1        bigint  NOT NULL DEFAULT '0',
    id2        bigint  NOT NULL DEFAULT '0',
    visibility smallint     NOT NULL DEFAULT '0',
    data       varchar(255) NOT NULL DEFAULT '',
    time       bigint  NOT NULL DEFAULT '0',
    version    bigint       NOT NULL DEFAULT '0',
    PRIMARY KEY (link_type, id1, id2)
) ORGANIZE BY ROW COMPRESS YES;

CREATE TABLE linkdb0.linktable_<LINK_TYPE_1>(
    ...
) ORGANIZE BY ROW COMPRESS YES;

...
\end{lstlisting}





\todo{Aussagekraft / elemntare Operationen abgeddeckt / meckern wenig OLAP}
\todo{Was ist ein faires Datenschema?}
\todo{Vlt. mal noch ergebnisse für JanusGraph gegenchecken.}
